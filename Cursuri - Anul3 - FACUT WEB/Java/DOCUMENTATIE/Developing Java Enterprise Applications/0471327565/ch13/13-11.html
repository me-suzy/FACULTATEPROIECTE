
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
	',height=' + height + ',resizable=1,scrollbars=yes');
	}
	//-->
	</SCRIPT>



<FONT FACE="Arial,Helvetica" SIZE="-1">
To access the contents, click the chapter and section titles.
</FONT>
<P>
<B>Developing Java Enterprise Applications</B>
<FONT SIZE="-1">
<BR>
<I>(Publisher: John Wiley & Sons, Inc.)</I>
<BR>
Author(s): Stephen Asbury ; Scott R. Weiner
<BR>
ISBN: 0471327565
<BR>
Publication Date: 02/01/99
</FONT>
<P>
<Script language="JavaScript">
function isIE4() 
{
    return( navigator.appName.indexOf("Microsoft") != -1 && (navigator.appVersion.charAt(0)=='4') );
 }
function bookMarkit()
{
        var url="http://www.itknowledge.com/PSUser/EWBookMarks.html?url="+window.location+"&isbn=0";
	parent.location.href=url;
        //var win = window.open(url,"myitk");
        //if(!isIE4())
        //       win.focus();

}
</Script>
<a href="javascript:bookMarkit();"><img src="/images/bookmarkit.gif" border=0 alt="Bookmark It" width=97 height=23></a>

<P>
<form name="Search" method="GET" action="http://search.earthweb.com/search97/search_redir.cgi">

<INPUT TYPE="hidden" NAME="Action" VALUE="Search">
<INPUT TYPE="hidden" NAME="SearchPage" VALUE="http://search.earthweb.com/search97/samples/forms/srchdemo.htm">
<INPUT TYPE="hidden" NAME="Collection" VALUE="ITK">
<INPUT TYPE="hidden" NAME="ResultTemplate" VALUE="itk-simple-intrabook.hts">
<INPUT TYPE="hidden" NAME="ViewTemplate" VALUE="view.hts">

<font face="arial, helvetica" size=2><b>Search this book:</b></font><br>
<INPUT NAME="queryText" size=50 VALUE="">&nbsp;<input type="submit" name="submitbutton" value="Go!">
<INPUT type=hidden NAME="section_on" VALUE="on">
<INPUT type=hidden NAME="section" VALUE="http://www.itknowledge.com/reference/standard/0471327565/">

</form>


<!-- Empty Reference Subhead -->

<!--ISBN=0471327565//-->
<!--TITLE=Developing Java Enterprise Applications//-->
<!--AUTHOR=Stephen Asbury//-->
<!--AUTHOR=Scott R. Weiner//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=13//-->
<!--PAGES=356-359//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="13-10.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="../ch14/14-01.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>No changes need to be made to the remote message sent, as the code that follows shows. This means that making an object activatable does not affect your core business logic.
</P>
<!-- CODE SNIP //-->
<PRE>
    public void send(String name, String s)
     throws RemoteException
    {
     System.out.println(name &#43; &#147;: &#148; &#43; s);
    }
</PRE>
<!-- END CODE SNIP //-->
<P>Because the server object will now be created and run by the activation system, there is no need to bootstrap the process, so the main method from previous examples has been deleted.
</P>
<H4 ALIGN="LEFT"><A NAME="Heading23"></A><FONT COLOR="#000077">Creating ConfigureServer</FONT></H4>
<P>The next step in the process is to create a setup program that actually installs your remote object class in the activation system. Define a class called ConfigureServer in the server package. This class has one method that installs the server in the activation system.
</P>
<P>Unlike the RMI server class that must stay alive as long as the implementation needs to be made available, the activatable class needs to be instantiated only when called. The ConfigureServer class passes information about the activatable class to the rmid process by registering an instance of the activatable class&#146;s stub class and a name with the rmiregistry. The information about the object is stored in an ActivationDesc (activation descriptor) object.</P>
<P>An ActivationDesc object contains the information necessary to activate an object, including the object&#146;s group identifier, class name, code location of the class, and optional object-specific initialization data in the form of a MarshalledObject. A descriptor registered with the activation system can be used to recreate/activate the object specified by the descriptor. The MarshalledObject in the object&#146;s descriptor is passed as the second argument to the remote object&#146;s constructor for object to use during reinitialization/activation. In this example, this is not included, because it is assumed that no default initialization data is needed.</P>
<P>For completeness, this example shows how the server can create an activation group to identify it. This group is associated with a Java virtual machine (VM). When objects in a group are activated, they run in this VM. Objects in other groups are assigned their own VM.</P>
<!-- CODE //-->
<PRE>
package server;

import java.util.*;

import java.rmi.*;
import java.rmi.activation.*;

import message.*;

public class ConfigureServer
{
    public static void main(String[] args) throws Exception
    {

     System.setSecurityManager(new RMISecurityManager());

     MessageServer srv;
     String servname = &#147;server.Server&#148;;

     String location = &#147;file:///temp/&#148;;

     MarshalledObject data = null;
     
     Properties props = new Properties();

     props.put(&#147;java.security.policy&#148;,
          &#147;/temp/server.policy&#148;);
<B>     ActivationGroupDesc.CommandEnvironment ace = null;</B>
     
     <B>ActivationGroupID id =
         ActivationGroup.getSystem().registerGroup(
             new ActivationGroupDesc(props, ace));

     ActivationDesc desc = new ActivationDesc(id
                    ,servname, location, data);

     srv = (MessageServer)Activatable.register(desc);</B>
       System.out.println(&#147;Registered and got Server_Stub&#148;);

<B>        Naming.rebind(MessageServer.SERVER_NAME, srv);</B>
       System.out.println(&#147;Exported MessageServer&#148;);

     System.exit(0);
    }
}
</PRE>
<!-- END CODE //-->
<P>Notice that the configuration program essentially puts the activatable object in rmid using the Activatable class&#146;s register method. This returns a stub that is registered with the rmiregistry. Clients access the stub, triggering the activation of the real object. Once the ConfigureServer code is complete, you can compile and run by changing the directory to the project root and issuing the following commands in Windows:
</P>
<!-- CODE //-->
<PRE>
javac server\*.java
rmic -d . server.Server
copy server c:\temp\server
copy server.policy \temp

start rmiregistry -J-Djava.security.policy=/temp/server.policy

start rmid

java -Djava.security.policy=server.policy -
Djava.rmi.server.codebase=file:///temp/ server.ConfigureServer
</PRE>
<!-- END CODE //-->
<P>Notice that when starting the configuration application, you must specify a CODEBASE that can take the form of a valid file or HTTP URL. The slash at the end of the URL is mandatory. Without the slash you will get a java.lang.ClassNotFoundException, as you would if your class could not be found for some other reason. In this example, the server files are copied to temp for convenience.
</P>
<P>To run the client, execute the following:</P>
<!-- CODE SNIP //-->
<PRE>
start java -Djava.security.manager
    -Djava.security.policy=server.policy client.Client Client1
</PRE>
<!-- END CODE SNIP //-->
<P>The results should be similar to the first example. The difference is that the server is not actually running (activated) until the client makes a request by sending it a message.
</P>
<H3><A NAME="Heading24"></A><FONT COLOR="#000077">Summary</FONT></H3>
<P>The goals for RMI are to support seamless remote invocation on objects in different virtual machines as well as callbacks from servers and applets. The semantics of RMI are well integrated with the Java programming language, so you need very little knowledge of network communication to invoke remote objects. Because RMI is divided into several layers, you could replace the default transport of TCP with some other protocol.
</P>
<P>RMI is both flexible and easy for the Java programmer to use. With the addition of activation in Java 2, RMI is also able to be responsive to client requests without taking up system resources. Clearly, for Java object communication, RMI is a good choice for creating enterprise solutions. However, if you intend to invoke methods of non-Java objects through CORBA, you may want to consider Java IDL or using an IIOP transport. Information on these topics can be found at the Sun Web site.</P>
<P>One last tidbit: When creating your RMI programs, you can use the built-in logging feature to help with debugging. Use the flag -Djava.rmi.server.logCalls=true when running a program to see a list of the calls that arrive to the RMI object.</P>
<P>The next chapter looks at a practical use of Java RMI: a file-locking server that provides multiuser access to networked files through Java.</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="13-10.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="../ch14/14-01.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>


<!-- 