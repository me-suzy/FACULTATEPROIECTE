
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
	',height=' + height + ',resizable=1,scrollbars=yes');
	}
	//-->
	</SCRIPT>



<FONT FACE="Arial,Helvetica" SIZE="-1">
To access the contents, click the chapter and section titles.
</FONT>
<P>
<B>Developing Java Enterprise Applications</B>
<FONT SIZE="-1">
<BR>
<I>(Publisher: John Wiley & Sons, Inc.)</I>
<BR>
Author(s): Stephen Asbury ; Scott R. Weiner
<BR>
ISBN: 0471327565
<BR>
Publication Date: 02/01/99
</FONT>
<P>
<Script language="JavaScript">
function isIE4() 
{
    return( navigator.appName.indexOf("Microsoft") != -1 && (navigator.appVersion.charAt(0)=='4') );
 }
function bookMarkit()
{
        var url="http://www.itknowledge.com/PSUser/EWBookMarks.html?url="+window.location+"&isbn=0";
	parent.location.href=url;
        //var win = window.open(url,"myitk");
        //if(!isIE4())
        //       win.focus();

}
</Script>
<a href="javascript:bookMarkit();"><img src="/images/bookmarkit.gif" border=0 alt="Bookmark It" width=97 height=23></a>

<P>
<form name="Search" method="GET" action="http://search.earthweb.com/search97/search_redir.cgi">

<INPUT TYPE="hidden" NAME="Action" VALUE="Search">
<INPUT TYPE="hidden" NAME="SearchPage" VALUE="http://search.earthweb.com/search97/samples/forms/srchdemo.htm">
<INPUT TYPE="hidden" NAME="Collection" VALUE="ITK">
<INPUT TYPE="hidden" NAME="ResultTemplate" VALUE="itk-simple-intrabook.hts">
<INPUT TYPE="hidden" NAME="ViewTemplate" VALUE="view.hts">

<font face="arial, helvetica" size=2><b>Search this book:</b></font><br>
<INPUT NAME="queryText" size=50 VALUE="">&nbsp;<input type="submit" name="submitbutton" value="Go!">
<INPUT type=hidden NAME="section_on" VALUE="on">
<INPUT type=hidden NAME="section" VALUE="http://www.itknowledge.com/reference/standard/0471327565/">

</form>


<!-- Empty Reference Subhead -->

<!--ISBN=0471327565//-->
<!--TITLE=Developing Java Enterprise Applications//-->
<!--AUTHOR=Stephen Asbury//-->
<!--AUTHOR=Scott R. Weiner//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=14//-->
<!--PAGES=373-376//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="14-03.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="14-05.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H4 ALIGN="LEFT"><A NAME="Heading9"></A><FONT COLOR="#000077">The LockServer</FONT></H4>
<P>The lock server provides one method for locking and another for unlocking. Both of these rely on the Boolean instance variable called locked, and both are synchronized. Clients that want to affect a lock file must first lock the network lock server. This is a bit more heavy handed than the shared scheme in which client&#146;s using different files had little interaction. Here, a client locking one file may have to wait for a client locking another file to unlock the server. However, this does ensure that no two clients are touching lock files at the same time or in a corrupt manner.
</P>
<P>The code for lock and unlock is very similar to the methods with the same name in the SharedFileLock object, because they perform the same function. The same wait-notifyAll technique is used to reduce CPU usage for threads waiting on the lock. Here is the code for the lock method, implemented as part of the global lock server:</P>
<!-- CODE //-->
<PRE>
    public synchronized void lock()
     {
        <B>while(locked)
        {
            </B>try
            {<B>
                wait();
</B>            }
            catch(Exception exp)
            {
            }
<B>        }
</B>        
<B>        locked = true;
</B>    }
    
    public synchronized void unlock()
    {
<B>        locked = false;
        notifyAll();</B>
    }
</PRE>
<!-- END CODE //-->
<P>The process of locking the server and creating lock files is encapsulated into the class GlobalFileLock.
</P>
<H4 ALIGN="LEFT"><A NAME="Heading10"></A><FONT COLOR="#000077">GlobalFileLock</FONT></H4>
<P>GlobalFileLock is not a remote class. It is a local class that accesses the NetworkLockServer via RMI. This is a different technique in that RMI is encapsulated behind a library class rather than providing library objects via RMI.
</P>
<P>The GlobalFileLock class that follows extends Object and implements the FileLock interface. Instance variables store File objects representing the file to lock and the lock file. A static hash table is used to provide unique global locks within a program, thus reducing memory usage, and the NetworkLockServer&#146;s remote stub.</P>
<!-- CODE //-->
<PRE>
import java.io.*;
 import java.util.*;
import java.rmi.*;

public class GlobalFileLock
 implements FileLock
{
    private File file;
    private File lockFile;
    
    private static NetworkLockServer server;
    private static Hashtable locks = new Hashtable();
</PRE>
<!-- END CODE //-->
<P>The GlobalFileLock class provides the setLockServer method to clients so that they can specify to the server host that the lock server is on. Remember that the lock server is used to ensure that lock files are not corrupted, so all of the programs that share a particular file should use the same lock server. All servers use the same name to register.
</P>
<!-- CODE //-->
<PRE>
    public synchronized static void setLockServer(String host)
     {
        String lookup;
        SecurityManager mng = new RMISecurityManager();
        
        try
        {
<B>            System.setSecurityManager(mng);
</B>        
<B>            lookup = &#147;rmi://&#148;+host+&#147;/&#148;+NetworkLockServer.NLS_NAME;
        
            server = (NetworkLockServer) Naming.lookup(lookup);
</B>        }
        catch(Exception exp)
        {
            server = null;
        }
    }
</PRE>
<!-- END CODE //-->
<P>For convenience, the SecurityManager is set when the connection is made to the server. You may want to change this setting if you are setting the SecurityManager somewhere else in the program. The getLockServer method is used to get the lock server object stub from the class. This method creates an object for the local host if the server has not already been provided.
</P>
<!-- CODE SNIP //-->
<PRE>
    protected static NetworkLockServer getLockServer()
     {
<B>        if(server == null) setLockServer(&#147;localhost&#148;);
</B>        return server;
    }
</PRE>
<!-- END CODE SNIP //-->
<P>To improve performance and reduce memory usage, a unique lock is provided for each path. The getLockFor method that follows implements this behavior. These locks are available only for a single program, so the absolute paths are unique. The unique locks are not shared with clients on other machines that may use different paths. However, they do afford us the ability to rely on synchronization of the lock object as well as locking the server.
</P>
<!-- CODE //-->
<PRE>
    public synchronized static GlobalFileLock 
      getLockFor(String path)
    {
        GlobalFileLock retVal = null;
        File tmp = new File(path);
        String absPath = tmp.getAbsolutePath();
        
        try
        {
            retVal = (GlobalFileLock) locks.get(absPath);
        
            if(retVal == null)
            {
                retVal = new GlobalFileLock(tmp);
                locks.put(absPath,retVal);
            }
        }
        catch(Exception exp)
        {
            retVal = null;
        }
        
        return retVal;
    }
</PRE>
<!-- END CODE //-->
<P>Again, to make sure that clients don&#146;t create their own GlobalFileLocks, the constructor is marked protected. This constructor is basically identical to the SharedFileLock&#146;s constructor, as you can see in the GlobalFileLock constructor that follows.
</P>
<!-- CODE //-->
<PRE>
    protected GlobalFileLock(File f) 
     throws RemoteException
    {
        String parent,name;
        String lckPath;
        
        file = f;
        
        parent = file.getParent();
        name = file.getName();
        
        lckPath = parent+File.separator+<B>&#147;.</B><B>&#148;</B>+name+<B>&#147;.</B>lck<B>&#148;</B>;
        
        lockFile = new File(lckPath);
    }
</PRE>
<!-- END CODE //-->
<P>Like the shared lock, the lockFile&#146;s existence is used to check whether the file is locked.
</P>
<!-- CODE SNIP //-->
<PRE>
    public synchronized boolean isLocked()
     {
        return lockFile.exists();
    }
</PRE>
<!-- END CODE SNIP //-->
<P>Requests to lock a file result in a call to the lock method. This method will check for a lock server; if one does not exist, then an exception is thrown.
</P>
<!-- CODE //-->
<PRE>
    //Waits to acquire a lock.
     public synchronized void lock()
        throws FileLockingException
    {
<B>        NetworkLockServer serv = getLockServer();
</B>        
<B>        if(serv == null)
            throw new FileLockingException(&#147;No Server Available&#148;);</B>
            
        // reallyLock, defined later, verifies lock has been placed.
        if(!reallyLock(serv))
        {
            throw new FileLockingException(<B>&#147;</B>Lock Unavailable<B>&#148;</B>);
        }
    }
</PRE>
<!-- END CODE //-->
<P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="14-03.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="14-05.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>


<!-- 