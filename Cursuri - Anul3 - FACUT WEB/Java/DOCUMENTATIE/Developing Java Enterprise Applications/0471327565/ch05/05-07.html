
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
	',height=' + height + ',resizable=1,scrollbars=yes');
	}
	//-->
	</SCRIPT>



<FONT FACE="Arial,Helvetica" SIZE="-1">
To access the contents, click the chapter and section titles.
</FONT>
<P>
<B>Developing Java Enterprise Applications</B>
<FONT SIZE="-1">
<BR>
<I>(Publisher: John Wiley & Sons, Inc.)</I>
<BR>
Author(s): Stephen Asbury ; Scott R. Weiner
<BR>
ISBN: 0471327565
<BR>
Publication Date: 02/01/99
</FONT>
<P>
<Script language="JavaScript">
function isIE4() 
{
    return( navigator.appName.indexOf("Microsoft") != -1 && (navigator.appVersion.charAt(0)=='4') );
 }
function bookMarkit()
{
        var url="http://www.itknowledge.com/PSUser/EWBookMarks.html?url="+window.location+"&isbn=0";
	parent.location.href=url;
        //var win = window.open(url,"myitk");
        //if(!isIE4())
        //       win.focus();

}
</Script>
<a href="javascript:bookMarkit();"><img src="/images/bookmarkit.gif" border=0 alt="Bookmark It" width=97 height=23></a>

<P>
<form name="Search" method="GET" action="http://search.earthweb.com/search97/search_redir.cgi">

<INPUT TYPE="hidden" NAME="Action" VALUE="Search">
<INPUT TYPE="hidden" NAME="SearchPage" VALUE="http://search.earthweb.com/search97/samples/forms/srchdemo.htm">
<INPUT TYPE="hidden" NAME="Collection" VALUE="ITK">
<INPUT TYPE="hidden" NAME="ResultTemplate" VALUE="itk-simple-intrabook.hts">
<INPUT TYPE="hidden" NAME="ViewTemplate" VALUE="view.hts">

<font face="arial, helvetica" size=2><b>Search this book:</b></font><br>
<INPUT NAME="queryText" size=50 VALUE="">&nbsp;<input type="submit" name="submitbutton" value="Go!">
<INPUT type=hidden NAME="section_on" VALUE="on">
<INPUT type=hidden NAME="section" VALUE="http://www.itknowledge.com/reference/standard/0471327565/">

</form>


<!-- Empty Reference Subhead -->

<!--ISBN=0471327565//-->
<!--TITLE=Developing Java Enterprise Applications//-->
<!--AUTHOR=Stephen Asbury//-->
<!--AUTHOR=Scott R. Weiner//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=05//-->
<!--PAGES=099-102//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="05-06.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="05-08.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>A reference contains the class name of the object as well as the class name and location of a factory object used to reproduce the object. These factories are discussed in detail in this section. Each address in the list identifies a communications end point for the same conceptual object. For example, an address could be a URL pointing at the data necessary to reconstruct the object. The order of the addresses in the list may be of significance to object factories that interpret the reference. Addresses are stored as instances of RefAddr.
</P>
<P>RefAddr is an abstract class that defines an association between a string type and an object. This object is called the <I>content.</I> To access the type and content, you can use these methods:</P>
<!-- CODE SNIP //-->
<PRE>
public String getType()
public Object getContent()
</PRE>
<!-- END CODE SNIP //-->
<P>The content is used to store information required to rebuild an object; and the type is used to identify the purpose of the content. For example, a reference for a Car object might store the value &#147;red&#148; under the type &#147;color&#148; and the value &#147;Saturn&#148; under the type &#147;make.&#148; RefAddr also overrides the equals and hash code methods to ensure that two references are equal if their contents and type are equal.
</P>
<P>JNDI defines two concrete subclasses of RefAddr. StringRefAddr stores a string, and BinaryRefAddr stores an array of bytes. These classes provide constructors to create the reference by specifying the content and type as arguments.</P>
<P>References are not synchronized. Threads that need to access a single reference concurrently should synchronize and provide locking.</P>
<P>In the case of the file system service provider, the object references are stored for a specified context in a file named .bindings. In the following example, a set of Car objects are created and bound to the file system. The main class, Bind.java, creates an initial context is set to the presentations subdirectory. Then several Car objects are instantiated, and they are bound into the file system by calling Context&#146;s rebind method. By using rebind, we can run the program repeatedly, replacing existing bindings with new ones. If the bind method was used and the example ran twice, an exception would be thrown. Finally, the car belonging to Cheryl is located using the lookup method of Context. The following code defines the Bind class.</P>
<!-- CODE //-->
<PRE>
import javax.naming.*;
import java.util.Hashtable;
import javax.naming.spi.ObjectFactory;

public class Bind
{
    public static void main(String[] args)
    {
Hashtable env = new Hashtable();
env.put(Context.INITIAL_CONTEXT_FACTORY,
&#147;com.sun.jndi.fscontext.RefFSContextFactory&#148;);

        // Specify the filesystem to search in this example.
        <B>env.put(Context.PROVIDER_URL,
            &#147;file:/tmp/marketing/presentations/&#148;);</B>

        try
        {
            Context initCtx = new InitialContext(env);
            /*
              Bind each customer into the file system.
              Use rebind in case they are already there.
              This way, earlier entries will be overwritten.
              Otherwise, if we used bind(), an exception would 
              be thrown if we run this twice.
            */
            <B>initCtx.rebind(&#147;Susan&#148;, new Car(&#147;Toyota&#148;,&#147;Camry&#148;));
            initCtx.rebind(&#147;Cheryl&#148;, new Car(&#147;Saturn&#148;,&#147;Coupe&#148;));
            initCtx.rebind(&#147;Nicole&#148;, new Car(&#147;Ford&#148;,&#147;Bronco&#148;));</B>

            <B>Car c = (Car)initCtx.lookup(&#147;Cheryl&#148;);</B>
            System.out.println(c);
        }catch(Exception e)
        {
            System.out.println(e);
            e.printStackTrace(System.out);
        }
    }
}
Here is what the /tmp/marketing/presentations/.bindings file contains after running the Bind program:
#This file is used by the JNDI FSContext.
#Sun Oct 11 19:50:11 PDT 1998
Susan/ClassName=Car
Nicole/RefAddr/0/Type=Car Description
Susan/RefAddr/0/Type=Car Description
Nicole/RefAddr/0/Encoding=String
Nicole/ClassName=Car
Cheryl/RefAddr/0/Type=Car Description
Nicole/FactoryName=CarFactory
Susan/FactoryName=CarFactory
Cheryl/ClassName=Car
Nicole/RefAddr/0/Content=Ford:Bronco
Cheryl/FactoryName=CarFactory
Cheryl/RefAddr/0/Content=Saturn:Coupe
Susan/RefAddr/0/Encoding=String
Susan/RefAddr/0/Content=Toyota:Camry
Cheryl/RefAddr/0/Encoding=String
</PRE>
<!-- END CODE //-->
<P>The information in this file is generated by the service provider and tells the provider what object mappings have been made for the subcontext, presentations. This .bindings file is FSContext specific, but it shows how the context can store reference information for the caller.
</P>
<P>The following code example is for the Car object. Notice that the class must implement the Referenceable interface, meaning it must implement a method called getReference(), which returns a Reference object. The Reference object should contain the name of the class, a string representation for reconstructing the object, the name of the factory class that reconstructs the object, and, if necessary, the location of the factory object. In this case, the make and model of the car are used to identify it. This information is stored in a StringRefAddr under the type &#147;Car Description.&#148; If the Car class was used to define a remote object, you may want to include the server name where the object resides.</P>
<!-- CODE //-->
<PRE>
import javax.naming.*;

/*
   This class is referenceable class that can be stored by service
   providers like the file system provider.
*/
<B>public class Car implements Referenceable</B>
{
    String make;
    String model;

    public Car(String mk, String md) 
    {
        make = mk;
        model = md;
    }

<B>    public Reference getReference() throws NamingException 
    {
        String cName = Car.class.getName();
        StringRefAddr cRef = new StringRefAddr(&#147;Car Description&#148;,
                make &#43; &#147;:&#148; &#43; model);
        String cfName = CarFactory.class.getName();

        Reference ref = new Reference(cName, cRef, cfName, null);

        return ref;
    }</B>

    public String toString()
    {
        return (make&#43;&#147; &#148;&#43;model);
    }
}
</PRE>
<!-- END CODE //-->
<P>When the Car object is bound, the service provider stores the reference values in the appropriate format for the service. Calling lookup causes the service provider to load the reference bound to the lookup name and use it to access the factory class responsible for reconstructing the object from the information provided by the reference. The CarFactory class code that follows implements the ObjectFactory interface, which is defined in javax.naming.spi. This interface includes the getObjectInstance method, which returns a newly constructed object based on the Reference object, obj. If a new object can&#146;t be reconstructed based on the parameters passed in, the factory is supposed to return null.
</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="05-06.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="05-08.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>


<!-- 