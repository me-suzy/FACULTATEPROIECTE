
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
	',height=' + height + ',resizable=1,scrollbars=yes');
	}
	//-->
	</SCRIPT>



<FONT FACE="Arial,Helvetica" SIZE="-1">
To access the contents, click the chapter and section titles.
</FONT>
<P>
<B>Developing Java Enterprise Applications</B>
<FONT SIZE="-1">
<BR>
<I>(Publisher: John Wiley & Sons, Inc.)</I>
<BR>
Author(s): Stephen Asbury ; Scott R. Weiner
<BR>
ISBN: 0471327565
<BR>
Publication Date: 02/01/99
</FONT>
<P>
<Script language="JavaScript">
function isIE4() 
{
    return( navigator.appName.indexOf("Microsoft") != -1 && (navigator.appVersion.charAt(0)=='4') );
 }
function bookMarkit()
{
        var url="http://www.itknowledge.com/PSUser/EWBookMarks.html?url="+window.location+"&isbn=0";
	parent.location.href=url;
        //var win = window.open(url,"myitk");
        //if(!isIE4())
        //       win.focus();

}
</Script>
<a href="javascript:bookMarkit();"><img src="/images/bookmarkit.gif" border=0 alt="Bookmark It" width=97 height=23></a>

<P>
<form name="Search" method="GET" action="http://search.earthweb.com/search97/search_redir.cgi">

<INPUT TYPE="hidden" NAME="Action" VALUE="Search">
<INPUT TYPE="hidden" NAME="SearchPage" VALUE="http://search.earthweb.com/search97/samples/forms/srchdemo.htm">
<INPUT TYPE="hidden" NAME="Collection" VALUE="ITK">
<INPUT TYPE="hidden" NAME="ResultTemplate" VALUE="itk-simple-intrabook.hts">
<INPUT TYPE="hidden" NAME="ViewTemplate" VALUE="view.hts">

<font face="arial, helvetica" size=2><b>Search this book:</b></font><br>
<INPUT NAME="queryText" size=50 VALUE="">&nbsp;<input type="submit" name="submitbutton" value="Go!">
<INPUT type=hidden NAME="section_on" VALUE="on">
<INPUT type=hidden NAME="section" VALUE="http://www.itknowledge.com/reference/standard/0471327565/">

</form>


<!-- Empty Reference Subhead -->

<!--ISBN=0471327565//-->
<!--TITLE=Developing Java Enterprise Applications//-->
<!--AUTHOR=Stephen Asbury//-->
<!--AUTHOR=Scott R. Weiner//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=12//-->
<!--PAGES=317-321//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="12-01.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="12-03.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>Creating a distributed object solution that is robust and well received by the industry is critical for its success. There are several features than any distributed object architecture should address. Here is a general description of these features.
</P>
<H4 ALIGN="LEFT"><A NAME="Heading4"></A><FONT COLOR="#000077">Creating a Solution</FONT></H4>
<P>A successful distributed object scheme, at a minimum, will:
</P>
<DL>
<DD><B>&#149;</B>&nbsp;&nbsp;Support heterogeneous platforms
<DD><B>&#149;</B>&nbsp;&nbsp;Allow discovery of an object
<DD><B>&#149;</B>&nbsp;&nbsp;Handle memory management issues
<DD><B>&#149;</B>&nbsp;&nbsp;Support communication among multiple programming languages
<DD><B>&#149;</B>&nbsp;&nbsp;Transparently handle network communication
<DD><B>&#149;</B>&nbsp;&nbsp;Provide a mechanism for storing references to remote objects
<DD><B>&#149;</B>&nbsp;&nbsp;Gain industry support
</DL>
<P>If you were to solve these problems yourself, you would come up with a solution similar to the most popular schemes today. These solutions include:
</P>
<DL>
<DD><B>&#149;</B>&nbsp;&nbsp;A mechanism for handling the communication issues between objects over standard protocols such as TCP/IP
<DD><B>&#149;</B>&nbsp;&nbsp;A scheme for locating remote objects
<DD><B>&#149;</B>&nbsp;&nbsp;A mechanism for marshaling and unmarshaling the object data over the network
<DD><B>&#149;</B>&nbsp;&nbsp;A scheme for providing an interface for a remote object in the local address space
<DD><B>&#149;</B>&nbsp;&nbsp;A reference scheme for keeping track of valid references to an object
</DL>
<P>In essence, to the programmer, distributed object application code should look just like a non-distributed application&#146;s code. Consider the following incomplete Java code sample.
</P>
<!-- CODE SNIP //-->
<PRE>
HelloObject h = new HelloObject();
h.sayHelloTo(&#147;John&#148;);
</PRE>
<!-- END CODE SNIP //-->
<P>In the distributed version, imagine a HelloObject is created and instantiated on a remote machine. This object is then registered with some type of naming service so that the object could be located later by clients. The distributed version might look something like this fictitious scheme:
</P>
<!-- CODE SNIP //-->
<PRE>
HelloInterface h = new HelloFactory(&#147;myserver&#148;, &#147;objectname&#148;);
h.sayHelloTo(&#147;John&#148;);
</PRE>
<!-- END CODE SNIP //-->
<P>The differences are subtle. First, the object returned is defined as an interface rather than an actual object. This way, the remote object implementation can change without affecting the code. Second, a mechanism is needed for locating the machine on which the remote object is located. A reasonable way to do this is to create a subclass of our distributed object mechanism class that takes as parameters the machine name and the registered name for the object. The distributed object mechanism is a class that performs the necessary communication to connect with the remote server, locate the named object, and instantiate a stand-in, or proxy, for the remote object in your client&#146;s address space. This proxy implements the HelloInterface; however, each method called is converted into a distributed message using some underlying protocol. In other words, when you call sayHelloTo(), the parameter &#147;john&#148; is sent to the remote object for processing. The mechanism for sending this data is hidden from the programmer, allowing for a transparent operation.
</P>
<P>Although the various distributed object schemes available today vary, they all solve the problems listed above.</P>
<H4 ALIGN="LEFT"><A NAME="Heading5"></A><FONT COLOR="#000077">Current Solutions</FONT></H4>
<P>Today, there are many distributed object solutions. Each addresses some or all of the issues mentioned previously, and more. An enterprise Java developer should be aware of three schemes:
</P>
<DL>
<DD><B>&#149;</B>&nbsp;&nbsp;Common Object Request Broker Architecture (CORBA) developed by the Object Management Group (OMG).
<DD><B>&#149;</B>&nbsp;&nbsp;nn Distributed Component Object Model (DCOM) developed by Microsoft.
<DD><B>&#149;</B>&nbsp;&nbsp;Remote Method Invocation (RMI) developed by Sun.
</DL>
<P>Let&#146;s take a look at each of these in more detail.
</P>
<P><FONT SIZE="+1"><B><I>OMG and CORBA</I></B></FONT></P>
<P>OMG was formed in 1989 by a group of vendors for the purpose of creating a standard architecture for networked distributed objects. The architecture that resulted is the Common Object Request Broker Architecture (CORBA). Both the International Standards Organization and X/Open have sanctioned CORBA as the standard architecture for distributed objects.
</P>
<BLOCKQUOTE>
<P><FONT SIZE="-1"><HR><B>NOTE:&nbsp;&nbsp;</B>For more information on OMG, you may want to check out their Web site at <A HREF="www.omg.org">www.omg.org</A>.
</FONT><HR>
</BLOCKQUOTE>
<P>Figure 12.3 illustrates the basic CORBA architecture.
</P>
<P>CORBA is a specification and architecture for creating, distributing, and managing distributed program objects in a network. CORBA relies on an Object Request Broker (ORB) to enable a client object to make a server request without having to know where in a network the server object or component is located and exactly what its interfaces are. In brokering a client request, an ORB may provide services such as:</P>
<DL>
<DD><B>&#149;</B>&nbsp;&nbsp;<B>Concurrency control service.</B> Allows an ORB to manage locks to data for which transactions or threads may compete.
<DD><B>&#149;</B>&nbsp;&nbsp;<B>Licensing service.</B> Allows use of a component to be measured for purposes of compensation.
<DD><B>&#149;</B>&nbsp;&nbsp;<B>Life-cycle services.</B> Defines how to create, copy, move, and delete a component.
<DD><B>&#149;</B>&nbsp;&nbsp;<B>Naming service.</B> Allows a component to find another component by name and supports existing naming systems or directories, including DCE, X.500, and Sun&#146;s NIS.
<DD><B>&#149;</B>&nbsp;&nbsp;<B>Persistence service.</B> Provides the ability to store data in object databases, relational databases, and plain files.
<DD><B>&#149;</B>&nbsp;&nbsp;<B>Properties service.</B> Lets a component contain a self-description that other components can use.
<P><A NAME="Fig3"></A><A HREF="javascript:displayWindow('images/12-03.jpg',500,434 )"><IMG SRC="images/12-03t.jpg"></A>
<BR><A HREF="javascript:displayWindow('images/12-03.jpg',500,434)"><FONT COLOR="#000077"><B>Figure 12.3</B></FONT></A>&nbsp;&nbsp;Basic CORBA architecture.</P>
<DD><B>&#149;</B>&nbsp;&nbsp;<B>Query service.</B> Allows a component to query a database. This service is based on the SQL3 specification and the Object Database Management Group&#146;s (ODMG&#146;s) Object Query Language (OQL).
<DD><B>&#149;</B>&nbsp;&nbsp;<B>Relationship service.</B> Creates and tracks dynamic associations between objects (references).
<DD><B>&#149;</B>&nbsp;&nbsp;<B>Transaction service.</B> Ensures that when a transaction is completed, changes are committed or, if not, that database changes are restored to their pretransaction state.
<DD><B>&#149;</B>&nbsp;&nbsp;<B>Security service.</B> Provide a mechanism to control access to the remote object.
</DL>
<P>To make requests or return replies between the ORBs, programs use the General Inter-ORB Protocol (GIOP) and, for the Internet, its Internet Inter-ORB Protocol (IIOP), as shown in Figure 12.4. IIOP is an object-oriented protocol that makes it possible for distributed programs written in different programming languages to communicate over the Internet. IIOP maps GIOP requests and replies to the Internet&#146;s Transmission Control Protocol (TCP) layer in each computer. The programmer&#146;s API layer hides this detail, however.
</P>
<P>IIOP use is becoming so popular that vendors that haven&#146;t fully implemented CORBA products are supporting IIOP. This means that your CORBA-compliant, or at least IIOP-compliant, objects should be able to communicate with these products easily.</P>
<P>Because of the wide acceptance of CORBA and, more important, IIOP, you can write an application that is able to interact with third-party objects and services. This means that you can purchase key technologies such as directory services and integrate them into your enterprise with little change in your own code or the way in which you design your applications.</P>
<P>A number of products have begun to use CORBA, and it appears to be the strategic architecture for distributed objects. The OMG currently claims to have over 700 member companies supporting, influencing, and using its architecture. Developing multitier applications using CORBA holds great promise because this technology supports interoperability across languages and platforms, as well as enhancing maintainability and adaptability of the application. CORBA has gained popularity, but Microsoft has not embraced it due to the fact that it has its own distributed object architecture, the Distributed Component Object Model (DCOM).</P>
<P><A NAME="Fig4"></A><A HREF="javascript:displayWindow('images/12-04.jpg',500,277 )"><IMG SRC="images/12-04t.jpg"></A>
<BR><A HREF="javascript:displayWindow('images/12-04.jpg',500,277)"><FONT COLOR="#000077"><B>Figure 12.4</B></FONT></A>&nbsp;&nbsp;ORBs and IIOP.<P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="12-01.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="12-03.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>


<!-- 