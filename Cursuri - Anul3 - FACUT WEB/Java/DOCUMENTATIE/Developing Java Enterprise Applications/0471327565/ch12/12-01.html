
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
	',height=' + height + ',resizable=1,scrollbars=yes');
	}
	//-->
	</SCRIPT>



<FONT FACE="Arial,Helvetica" SIZE="-1">
To access the contents, click the chapter and section titles.
</FONT>
<P>
<B>Developing Java Enterprise Applications</B>
<FONT SIZE="-1">
<BR>
<I>(Publisher: John Wiley & Sons, Inc.)</I>
<BR>
Author(s): Stephen Asbury ; Scott R. Weiner
<BR>
ISBN: 0471327565
<BR>
Publication Date: 02/01/99
</FONT>
<P>
<Script language="JavaScript">
function isIE4() 
{
    return( navigator.appName.indexOf("Microsoft") != -1 && (navigator.appVersion.charAt(0)=='4') );
 }
function bookMarkit()
{
        var url="http://www.itknowledge.com/PSUser/EWBookMarks.html?url="+window.location+"&isbn=0";
	parent.location.href=url;
        //var win = window.open(url,"myitk");
        //if(!isIE4())
        //       win.focus();

}
</Script>
<a href="javascript:bookMarkit();"><img src="/images/bookmarkit.gif" border=0 alt="Bookmark It" width=97 height=23></a>

<P>
<form name="Search" method="GET" action="http://search.earthweb.com/search97/search_redir.cgi">

<INPUT TYPE="hidden" NAME="Action" VALUE="Search">
<INPUT TYPE="hidden" NAME="SearchPage" VALUE="http://search.earthweb.com/search97/samples/forms/srchdemo.htm">
<INPUT TYPE="hidden" NAME="Collection" VALUE="ITK">
<INPUT TYPE="hidden" NAME="ResultTemplate" VALUE="itk-simple-intrabook.hts">
<INPUT TYPE="hidden" NAME="ViewTemplate" VALUE="view.hts">

<font face="arial, helvetica" size=2><b>Search this book:</b></font><br>
<INPUT NAME="queryText" size=50 VALUE="">&nbsp;<input type="submit" name="submitbutton" value="Go!">
<INPUT type=hidden NAME="section_on" VALUE="on">
<INPUT type=hidden NAME="section" VALUE="http://www.itknowledge.com/reference/standard/0471327565/">

</form>


<!-- Empty Reference Subhead -->

<!--ISBN=0471327565//-->
<!--TITLE=Developing Java Enterprise Applications//-->
<!--AUTHOR=Stephen Asbury//-->
<!--AUTHOR=Scott R. Weiner//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=12//-->
<!--PAGES=313-317//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="../ch11/11-06.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="12-02.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H2><A NAME="Heading1"></A><FONT COLOR="#000077">CHAPTER 12<BR>Overview of Distributed Objects
</FONT></H2>
<P>The next two chapters deal with distributed object solutions using a Java technology called Remote Method Invocation (RMI). This chapter provides you with a brief overview of widely accepted distributed object technologies. This overview is intended to provide you with the background necessary to understand the benefits and use of RMI. If you already have grounding in distributed objects, this chapter is a useful refresher. If you don&#146;t feel you need a refresher, you might want to skip ahead to Chapter 13, &#147;Introduction to Java RMI.&#148;
</P>
<H3><A NAME="Heading2"></A><FONT COLOR="#000077">Distributed Computing</FONT></H3>
<P>Developing enterprise applications often requires integrating multiple processes and the applications handling them. These applications may be running on separate computers. In order to achieve communication between applications, a scheme for sending messages from one process to another must be developed.
</P>
<P><I>Distributed computing</I> refers to computer applications in which the application code, the data it works on, and the actual computations performed are spread across multiple computers. The goal is to distribute the heavy computing and network load that users put on an enterprise application by leveraging the processing power of multiple computers.</P>
<P>One of the benefits for creating a distributed application is that the design of one component can be used by several others. As the example in Figure 12.1 illustrates, you could create a credit card verification subsystem that is simultaneously used by a point-of-sales system in a retail store as well as an electronic commerce Web site.</P>
<P><A NAME="Fig1"></A><A HREF="javascript:displayWindow('images/12-01.jpg',500,408 )"><IMG SRC="images/12-01t.jpg"></A>
<BR><A HREF="javascript:displayWindow('images/12-01.jpg',500,408)"><FONT COLOR="#000077"><B>Figure 12.1</B></FONT></A>&nbsp;&nbsp;A distributed computing example.</P>
<P>Rather than building the credit card verification component into every application that uses it, we would typically establish a distributed messaging protocol that allows messages to be sent from one application to another. In this way, the credit card application can be considered as just another network service that can be accessed and utilized by several applications.
</P>
<P>Examples of messaging schemes that applications have used include:</P>
<DL>
<DD><B>Sockets.</B> The method of standard TCP sockets for communication between two processes requires the developer to write an extensive amount of communication code because sockets do not define high-level data structures, such as the notion of a credit card object. In addition, socket programming requires that you handle data loss and marshaling of the information being sent.
<DD><B>Remote procedure calls (RPC).</B> This higher-level mechanism handles some of the communication issues but still doesn&#146;t provide high-level data structures, only a simple function calling mechanism. RPC is simply a library of function calls (typically implemented with a C interface) that handles the actual communication between two applications. You still have to handle most of the data type issues yourself. This means that your credit card object would have to be broken down into its raw elements such as credit card number, date, name, and so on. The elements would have to be reconstructed on the other side of the connection for processing.
</DL>
<P>Programmers have used many schemes, but most of these older strategies make the developer think too much about solving the network communication issues as opposed to solving critical business problems. This is an issue because it means that changing the behavior of the service provider or one of its clients can mean a drastic amount of coding to handle network communication issues such as network failure, data formats, and so on. This is a <I>plumbing</I> problem, and highly paid enterprise developers should be focused on more critical business process issues. As object-oriented programming grew in popularity, it became obvious that the inherent mapping between object modeling and business processes would be a natural fit. It wasn&#146;t long before object designers began to look for a way to send these object encapsulations of business processes over the network. This was the beginning of distributed objects.</P>
<H3><A NAME="Heading3"></A><FONT COLOR="#000077">Distributed Objects</FONT></H3>
<P>A <I>distributed object</I> mechanism allows objects implemented on one computer to send messages to objects running in another memory address space, typically across the network. In other words, if a standard mechanism could be developed so that an object developed in, say, Java could transparently send messages to an object on another computer as easily as it sends messages to an object in the same application, objects could truly bridge the gap between business processes and software development in a distributed application environment.</P>
<P>The number of hurdles in accomplishing this task is enormous. For instance, the designer of such a distributed object system would have to handle issues such as:</P>
<DL>
<DD><B>Heterogeneous platforms.</B> In a distributed object environment, it is reasonable to expect that the various software components and network services you want to access are running on different hardware platforms under various operating systems. The transmission mechanism for these distributed objects has to manage data format issues such as byte ordering.
<DD><B>Location. </B>In a distributed object environment, there must be some scheme for locating the object that will provide you the service. For example, how does the point-of-sales application locate the credit card verification object and the specific machine on which it is located?
<DD><B>Memory management.</B> Sending a message to an object that is actually in another address space adds several new issues to the object paradigm. For example, if you wanted to request a customer name from a <I>remote</I> object, how does the string representing the name get passed back to you? By reference? By value? It can&#146;t truly be by reference, because references to a foreign address space have no meaning in your application. Figure 12.2 illustrates this concept. If the name is sent by value, what happens if the value changes? The original string won&#146;t be updated, only the copy will be, so how would you have the original string updated? In addition, if you have a reference to a remote object, how does the remote object application &#147;know&#148; when it can delete or garbage-collect the object? The distributed object scheme would have to handle these issues and several others.
<P><A NAME="Fig2"></A><A HREF="javascript:displayWindow('images/12-02.jpg',500,413 )"><IMG SRC="images/12-02t.jpg"></A>
<BR><A HREF="javascript:displayWindow('images/12-02.jpg',500,413)"><FONT COLOR="#000077"><B>Figure 12.2</B></FONT></A>&nbsp;&nbsp;Accessing a remote object.</P>
<DD><B>Multiple languages.</B> Unfortunately, no one computer language meets all application needs. This means that it is reasonable that distributed object services and their client applications could be written in different programming languages and therefore have completely different language concepts. For example, how does a Java application send messages to a C<SMALL>&#43;&#43;</SMALL> object when the C<SMALL>&#43;&#43;</SMALL> language supports multiple inheritance and the Java language doesn&#146;t, or vice versa? The distributed object scheme should be able to perform language mappings. This way, a message sent from an application written in C<SMALL>&#43;&#43;</SMALL> could be interpreted and executed by a Java object running on another computer or in another address space on the same computer.
<DD><B>Network communication.</B> Object messages would have to be sent in such a way that the client application did not have to deal with the networking issues required to communicate with the object service it was connecting to. This means a mechanism is required to handle network protocols and network failure. For instance, when you send a message inside an application, you always expect the message to be received. In a distributed object scheme, due to hardware or software difficulties along the way, it is quite possible that the message will never reach its destination. Although it is impossible for any networking technology to completely hide the inherent issues in distributed computing, the more the technology can handle without programmer knowledge, the better.
<DD><B>Persistence. </B>Communicating with objects over a network also brings up the question of how to maintain a reference to the remote object so that later sessions with your client application are possible. Some global referencing scheme may be necessary.
<DD><B>Standardization.</B> Even if solutions to all these problems and the dozens of other issues that have emerged are found, the most pressing one is that of standards. If the distributed object scheme is not widely accepted, it has little value. After all, what difference does it make if we have a way of connecting applications and services together with a seamless object layer if third-party applications and vendors don&#146;t support the mechanism? How useful is it to create a distributed object layer that no one supports? For a distributed object solution to truly benefit the industry, it must have the support of advocates and a standards body.
</DL>
<P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="../ch11/11-06.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="12-02.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>


<!-- 