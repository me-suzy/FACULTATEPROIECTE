
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
	',height=' + height + ',resizable=1,scrollbars=yes');
	}
	//-->
	</SCRIPT>



<FONT FACE="Arial,Helvetica" SIZE="-1">
To access the contents, click the chapter and section titles.
</FONT>
<P>
<B>Developing Java Enterprise Applications</B>
<FONT SIZE="-1">
<BR>
<I>(Publisher: John Wiley & Sons, Inc.)</I>
<BR>
Author(s): Stephen Asbury ; Scott R. Weiner
<BR>
ISBN: 0471327565
<BR>
Publication Date: 02/01/99
</FONT>
<P>
<Script language="JavaScript">
function isIE4() 
{
    return( navigator.appName.indexOf("Microsoft") != -1 && (navigator.appVersion.charAt(0)=='4') );
 }
function bookMarkit()
{
        var url="http://www.itknowledge.com/PSUser/EWBookMarks.html?url="+window.location+"&isbn=0";
	parent.location.href=url;
        //var win = window.open(url,"myitk");
        //if(!isIE4())
        //       win.focus();

}
</Script>
<a href="javascript:bookMarkit();"><img src="/images/bookmarkit.gif" border=0 alt="Bookmark It" width=97 height=23></a>

<P>
<form name="Search" method="GET" action="http://search.earthweb.com/search97/search_redir.cgi">

<INPUT TYPE="hidden" NAME="Action" VALUE="Search">
<INPUT TYPE="hidden" NAME="SearchPage" VALUE="http://search.earthweb.com/search97/samples/forms/srchdemo.htm">
<INPUT TYPE="hidden" NAME="Collection" VALUE="ITK">
<INPUT TYPE="hidden" NAME="ResultTemplate" VALUE="itk-simple-intrabook.hts">
<INPUT TYPE="hidden" NAME="ViewTemplate" VALUE="view.hts">

<font face="arial, helvetica" size=2><b>Search this book:</b></font><br>
<INPUT NAME="queryText" size=50 VALUE="">&nbsp;<input type="submit" name="submitbutton" value="Go!">
<INPUT type=hidden NAME="section_on" VALUE="on">
<INPUT type=hidden NAME="section" VALUE="http://www.itknowledge.com/reference/standard/0471327565/">

</form>


<!-- Empty Reference Subhead -->

<!--ISBN=0471327565//-->
<!--TITLE=Developing Java Enterprise Applications//-->
<!--AUTHOR=Stephen Asbury//-->
<!--AUTHOR=Scott R. Weiner//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=20//-->
<!--PAGES=497-500//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="../ch19/19-02.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="20-02.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<H2><A NAME="Heading1"></A><FONT COLOR="#000077">CHAPTER 20<BR>Programming with the Java Messaging Service
</FONT></H2>
<P>As you discovered in Chapter 19, &#147;What Are Messaging and the Java Messaging Service?&#148; messaging can be a powerful technique for building enterprise applications. In particular, the persistence and easy use of messaging makes it an interesting part of your programming tool kit. This chapter discusses the techniques and concepts used to program with the Java Messaging Service (JMS).
</P>
<P>JMS is actually two interface definitions. The first interface defines the relationship between a client and the messaging service. The second interface defines the relationship between JMS and an application server that hosts it. This chapter focuses on the client side of the JMS specification and discusses the application server interfaces only minimally.</P>
<P>JMS relies on a number of the other interfaces in the Enterprise Java suite. In particular, JNDI and JTA are both part of the JMS specification. Although this chapter does not focus on these relationships, you need to understand the basic principles behind JNDI to completely understand the examples. Please refer to Chapter 5, &#147;Using JNDI,&#148; for detailed information on JNDI.</P>
<P>JMS, like JDBC, is an interface-based API. This means that you can&#146;t use JMS without a JMS provider that implements the JMS interfaces. The provider implements the services discussed in this chapter using whatever underlying mechanism it chooses. For example, Active Software might implement JMS using its broker technology, while IBM might rely on MQ-series for the underlying messaging transportation. A JMS provider that we created and called MiniJMS is used for all of the examples in this book and included on the CD-ROM.</P>
<H3><A NAME="Heading2"></A><FONT COLOR="#000077">MiniJMS: The Example Provider</FONT></H3>
<P>MiniJMS is an almost complete implementation of the JMS specification. The implementation of MiniJMS uses RMI, JNDI, and JDBC, tying together a number of the concepts discussed in this book. In fact, it is such a good example of how these technologies can be combined that Chapter 26, &#147;MiniJMS: A Java Messaging Service Provider,&#148; includes a discussion of the MiniJMS implementation.
</P>
<P>MiniJMS implements the majority of the JMS API, but it is not intended for commercial use. It does not currently support distributed use, in the sense that the JNDI service provider, the file system context, doesn&#146;t support networked operation. This implementation also doesn&#146;t support the message selectors discussed in this chapter and is not designed to plug into an application server or to be used with distributed transactions.</P>
<P>Despite these limitations, MiniJMS does provide an example of a JMS provider that uses server-based message management. It provides persistent messaging, saving messages to a JDBC database and the file system. Also, MiniJMS provides an easy testing ground for understanding and testing JMS applications. On top of this, MiniJMS implements both of the messaging models defined by JMS, even though this is not required by the specification.</P>
<P>In order to use MiniJMS, install the JMS libraries on your computer; you&#146;ll find them on the CD-ROM in a package called javax.jms. You will also need the JNDI libraries discussed in Chapter 5, and the file system JNDI service provider. All of these libraries can be obtained from the CD-ROM or the JavaSoft Web site at www.javasoft.com. All of these libraries must appear in your class path.</P>
<H4 ALIGN="LEFT"><A NAME="Heading3"></A><FONT COLOR="#000077">Running the Examples</FONT></H4>
<P>In addition to the JMS and JNDI packages, add the minijms.jar file to your class path. This file contains the class and properties files for MiniJMS and is available on the CD-ROM in the Chapter_20 directory.
</P>
<BLOCKQUOTE>
<P><FONT SIZE="-1"><HR><B>NOTE:&nbsp;&nbsp;</B>The examples in this chapter were tested on JDK 1.1.6 with Swing 1.0.3. If you do not have these versions, be sure that you have a newer version, such as Java 2. Note, however, that Java 2 does change the package names for Swing, so you may need to update the examples for use with this version. If possible, based on the production schedule for this book and Sun&#146;s release schedule, a set of the examples for Java 2 and JDK 1.1.n are provided on the CD-ROM. If you are unfamiliar with Swing, we highly suggest our book <I>Programming with JFC</I> (John Wiley &amp Sons, 1997).
</FONT><HR>
</BLOCKQUOTE>
<P>The user interface code in this example is secondary to the JMS code and can be skimmed over.
</P>
<P>To run the examples from this chapter, follow these steps:</P>
<DL>
<DD><B>1.</B>&nbsp;&nbsp;Create an ODBC data source called MiniJMS. Use the Microsoft Access database file, provided on the CD-ROM, which contains the data for this database; or use the MiniJMSserver.BuildDB script to create a database using a different database vendor. See Chapter 26 for more details on BuildDB.
<DD><B>2.</B>&nbsp;&nbsp;Create a directory called c:/temp/jndistore for use by the JNDI file system context. If you don&#146;t want to use this directory or you are not using a Windows-based machine, edit the server properties file as discussed in Chapter 26.
<DD><B>3.</B>&nbsp;&nbsp;Start the RMI registry.
<DD><B>4.</B>&nbsp;&nbsp;Start the MiniJMS server. This server is called minijmsserver.MiniJMS and takes a single command-line argument containing the IP address of the local host. This address is used to find the RMI registry. For example, you might enter:
<!-- CODE SNIP //-->
<PRE>
  &gt; java -nojit minijmsserver.MiniJMS 192.168.0.172
</PRE>
<!-- END CODE SNIP //-->
</DL>
<P>Notice that the just-in-time compiler isn&#146;t used, because a bug in some versions of the JDK causes errors when using RMI. You may not need to take this precaution with your installation. Now that the server is running, you can run the examples from this chapter and Chapter 21, &#147;A JMS-Based Alarm System.&#148;
</P>
<H3><A NAME="Heading4"></A><FONT COLOR="#000077">JMS Fundamentals</FONT></H3>
<P>JMS divides messaging into two categories: point-to-point and publish-subscribe messaging, as discussed in Chapter 19, &#147;What Are Messaging and the Java Messaging Service?&#148; Both of these mechanisms build on the same fundamental ideas. This first section of the chapter discusses these fundamental concepts and the interfaces that represent them. The next two sections introduce the specific interfaces for the two messaging protocols and provide examples for each.
</P>
<P>Perhaps the most fundamental concept in JMS is that of a message. As mentioned in Chapter 19, a message is an object that encapsulates a real-world message to be distributed or received, using JMS. These messages travel between destinations defined in JMS by the Destination interface. A JMS provider&#146;s job is to get the message from the sender to the destination and on to any receivers that have registered to receive messages for that destination.</P>
<H4 ALIGN="LEFT"><A NAME="Heading5"></A><FONT COLOR="#000077">Destinations</FONT></H4>
<P>Destinations define a provider-independent representation of a message delivery point. The Destination interface doesn&#146;t define any methods. Rather, it is any object that the provider chooses to use that defines the location to which messages are delivered. JMS defines two destination subtypes: Queues and Topics. These define the concept of a persistent queue and a shared, subscriber-based topic, respectively. The most important aspect of a destination is that its implementation is defined by the JMS provider. This means that the provider can use whatever mechanism it chooses to implement the Destination interface, while clients can use the Destination objects without seeing the implementation details.
</P>
<P>The messages that you send to a destination can be persistent, meaning that they will be sent to a client, even if the client is currently unavailable. They can also be guaranteed via persistence, meaning that the JMS libraries will not say a message is sent until it is stored using a transacted resource such as a database. This persistence ensures message delivery in an enterprise-level situation.</P>
<P>Because JMS is expected to work in a network environment, not within a single application, destinations may represent a network address or a named location in a central server. In any case, the client that wants to send a message to the destination needs to create a connection to the JMS provider&#146;s services. This connection is created using a connection factory.</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="../ch19/19-02.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="20-02.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>


<!-- 