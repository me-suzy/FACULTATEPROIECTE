
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
	',height=' + height + ',resizable=1,scrollbars=yes');
	}
	//-->
	</SCRIPT>



<FONT FACE="Arial,Helvetica" SIZE="-1">
To access the contents, click the chapter and section titles.
</FONT>
<P>
<B>Developing Java Enterprise Applications</B>
<FONT SIZE="-1">
<BR>
<I>(Publisher: John Wiley & Sons, Inc.)</I>
<BR>
Author(s): Stephen Asbury ; Scott R. Weiner
<BR>
ISBN: 0471327565
<BR>
Publication Date: 02/01/99
</FONT>
<P>
<Script language="JavaScript">
function isIE4() 
{
    return( navigator.appName.indexOf("Microsoft") != -1 && (navigator.appVersion.charAt(0)=='4') );
 }
function bookMarkit()
{
        var url="http://www.itknowledge.com/PSUser/EWBookMarks.html?url="+window.location+"&isbn=0";
	parent.location.href=url;
        //var win = window.open(url,"myitk");
        //if(!isIE4())
        //       win.focus();

}
</Script>
<a href="javascript:bookMarkit();"><img src="/images/bookmarkit.gif" border=0 alt="Bookmark It" width=97 height=23></a>

<P>
<form name="Search" method="GET" action="http://search.earthweb.com/search97/search_redir.cgi">

<INPUT TYPE="hidden" NAME="Action" VALUE="Search">
<INPUT TYPE="hidden" NAME="SearchPage" VALUE="http://search.earthweb.com/search97/samples/forms/srchdemo.htm">
<INPUT TYPE="hidden" NAME="Collection" VALUE="ITK">
<INPUT TYPE="hidden" NAME="ResultTemplate" VALUE="itk-simple-intrabook.hts">
<INPUT TYPE="hidden" NAME="ViewTemplate" VALUE="view.hts">

<font face="arial, helvetica" size=2><b>Search this book:</b></font><br>
<INPUT NAME="queryText" size=50 VALUE="">&nbsp;<input type="submit" name="submitbutton" value="Go!">
<INPUT type=hidden NAME="section_on" VALUE="on">
<INPUT type=hidden NAME="section" VALUE="http://www.itknowledge.com/reference/standard/0471327565/">

</form>


<!-- Empty Reference Subhead -->

<!--ISBN=0471327565//-->
<!--TITLE=Developing Java Enterprise Applications//-->
<!--AUTHOR=Stephen Asbury//-->
<!--AUTHOR=Scott R. Weiner//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=20//-->
<!--PAGES=503-505//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="20-02.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="20-04.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>The Connection interface also defines a close method. This is true of many of the JMS objects. Because JMS is expected to provide network-based messaging, each of the provider&#146;s objects might represent network or server resources. When done, close all objects that provide a method for doing so.
</P>
<P>The connections exception listener is an object that implements the single method:</P>
<!-- CODE SNIP //-->
<PRE>
public void onException(JMSException exception)
</PRE>
<!-- END CODE SNIP //-->
<P>The connection notifies the listener of major exceptions. However, this is a provider-specific feature, and JMS doesn&#146;t dictate when or even if this listener is used.
</P>
<P>Both messaging models have a connection factory that takes a user name and password when creating a connection. This identification can be used by the connection to identify the client or user to the JMS server. This identification is optional, and it is up to the provider how an unidentified client is treated.</P>
<P>Connections represent the channel to the JMS provider. To control this channel, the connection objects have a start and stop method. Stop halts all message traffic on the connection, and start resumes the traffic. These methods are useful if you want to initialize your program before receiving messages and don&#146;t want the connection to remain in its default running state while you initialize your code.</P>
<P>A JMS Connection can return a ConnectionMetaData object that contains information about the connection&#146;s JMS provider. In particular, the ConnectionMetaData interface defines methods for accessing the provider version and name, as well as the JMS version that the provider supports.</P>
<H4 ALIGN="LEFT"><A NAME="Heading9"></A><FONT COLOR="#000077">Sessions</FONT></H4>
<P>One of a connection&#146;s main jobs, creating sessions, is hidden by the default API. Each of the subconnection types, QueueConnection and TopicConnection, provides methods for creating sessions that support their specific messaging model. As defined by the JMS specification, a session is &#147;a single-threaded context for producing and consuming messages.&#148; In other words, a session is the object that provides access to the connection for code that wants to send and receive messages. More important, the session does this in a single-threaded model by serializing message sending and delivery.
</P>
<P>For example, if client A sends four messages, client B&#146;s session will deliver these four messages one after the other, not at the same time. Even if two programs send a third program messages simultaneously, the session will ensure that the receivers will be notified of one message at a time. Although notification is synchronized, it may occur in a different thread from the one that created the session if the program uses message listeners to receive notification. These listeners are discussed in the &#147;MessageListeners&#148; section and are similar to event listeners in AWT and Swing.</P>
<P>Sessions can also provide a transaction context for messaging. This context stores messages for delivery until they are committed, at which point the messages are sent as a block. An example of how you might use transactions with messages is shown in Figure 20.1. In this example, several sessions are created and sent to the session, but they are not really sent to the server until the transaction is committed. Sessions can also be rolled back, allowing the client to prepare a group of messages to send, then &#147;change its mind&#148; and cancel all of the sends in a single block.</P>
<P>Transactions are optional with messaging and, if turned off, messages are delivered when they are sent.</P>
<P>Sessions without transactions rely on the concept of acknowledgment to indicate when a message is received. When a JMS client acknowledges receipt of a message, that message will not be sent to the client again. In this respect, committing a transacted session is the same as acknowledging all of the messages received in the transaction scope. Because acknowledgment is like a mini-transaction, it too has several options. These are listed and described in Table 20.2. Each of these values is defined as a static variable in the Message interface.</P>
<P>Sessions provide a set of methods for creating message objects. These methods are used by the client to create messages for sending. By providing methods in the session for creating messages, the JMS specification hides the classes used to implement these messages from the programmer. These methods and the others defined in the Session interface are described in Table 20.3. The various types of messages created are discussed later in this chapter.</P>
<P>As with a connection, a session should be closed when a program is done using it.</P>
<P><FONT SIZE="+1"><B><I>MessageListeners</I></B></FONT></P>
<P>Sessions allow the programmer to assign to them an object called a <I>message listener</I>. This listener receives notification of any messages received by this session. However, this facility is really part of the Application Server interface and is not intended for normal client use, because it prohibits all other forms of message delivery.</P>
<P><A NAME="Fig1"></A><A HREF="javascript:displayWindow('images/20-01.jpg',403,420 )"><IMG SRC="images/20-01t.jpg"></A>
<BR><A HREF="javascript:displayWindow('images/20-01.jpg',403,420)"><FONT COLOR="#000077"><B>Figure 20.1</B></FONT></A>&nbsp;&nbsp;Transacted messages.</P>
<P>That said, the MessageListener interface is also used by other objects to provide an asynchronous message delivery mechanism. A message listener defines a single method:
</P>
<!-- CODE SNIP //-->
<PRE>
public void onMessage(Message message)
</PRE>
<!-- END CODE SNIP //-->
<TABLE WIDTH="100%">
<TR>
<TD CAPTION ALIGN="LEFT" COLSPAN="2"><B>Table 20.2</B> Acknowledgment Options
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TH VALIGN="TOP" WIDTH="25%" ALIGN="LEFT">OPTION
<TH VALIGN="TOP" ALIGN="LEFT">DESCRIPTION
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TD VALIGN="TOP" ALIGN="LEFT"><SMALL>AUTO_ACKNOWLEDGE</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT">Each message is automatically acknowledged when it is delivered.
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TD VALIGN="TOP" ALIGN="LEFT"><SMALL>CLIENT_ACKNOWLEDGE</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT">Clients must acknowledge each message programmatically.
<TR>
<TD COLSPAN="2"><HR>
<TR>
<TD VALIGN="TOP" ALIGN="LEFT"><SMALL>DUPS_OK_ACKNOWLEDGE</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT">Messages are acknowledged lazily, and a message may be delivered twice if the connection is broken unexpectedly.
<TR>
<TD COLSPAN="2"><HR>
</TABLE>
<P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="20-02.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="20-04.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>


<!-- 