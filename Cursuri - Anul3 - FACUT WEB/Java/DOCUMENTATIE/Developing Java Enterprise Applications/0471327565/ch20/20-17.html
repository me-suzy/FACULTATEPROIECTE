
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
	',height=' + height + ',resizable=1,scrollbars=yes');
	}
	//-->
	</SCRIPT>



<FONT FACE="Arial,Helvetica" SIZE="-1">
To access the contents, click the chapter and section titles.
</FONT>
<P>
<B>Developing Java Enterprise Applications</B>
<FONT SIZE="-1">
<BR>
<I>(Publisher: John Wiley & Sons, Inc.)</I>
<BR>
Author(s): Stephen Asbury ; Scott R. Weiner
<BR>
ISBN: 0471327565
<BR>
Publication Date: 02/01/99
</FONT>
<P>
<Script language="JavaScript">
function isIE4() 
{
    return( navigator.appName.indexOf("Microsoft") != -1 && (navigator.appVersion.charAt(0)=='4') );
 }
function bookMarkit()
{
        var url="http://www.itknowledge.com/PSUser/EWBookMarks.html?url="+window.location+"&isbn=0";
	parent.location.href=url;
        //var win = window.open(url,"myitk");
        //if(!isIE4())
        //       win.focus();

}
</Script>
<a href="javascript:bookMarkit();"><img src="/images/bookmarkit.gif" border=0 alt="Bookmark It" width=97 height=23></a>

<P>
<form name="Search" method="GET" action="http://search.earthweb.com/search97/search_redir.cgi">

<INPUT TYPE="hidden" NAME="Action" VALUE="Search">
<INPUT TYPE="hidden" NAME="SearchPage" VALUE="http://search.earthweb.com/search97/samples/forms/srchdemo.htm">
<INPUT TYPE="hidden" NAME="Collection" VALUE="ITK">
<INPUT TYPE="hidden" NAME="ResultTemplate" VALUE="itk-simple-intrabook.hts">
<INPUT TYPE="hidden" NAME="ViewTemplate" VALUE="view.hts">

<font face="arial, helvetica" size=2><b>Search this book:</b></font><br>
<INPUT NAME="queryText" size=50 VALUE="">&nbsp;<input type="submit" name="submitbutton" value="Go!">
<INPUT type=hidden NAME="section_on" VALUE="on">
<INPUT type=hidden NAME="section" VALUE="http://www.itknowledge.com/reference/standard/0471327565/">

</form>


<!-- Empty Reference Subhead -->

<!--ISBN=0471327565//-->
<!--TITLE=Developing Java Enterprise Applications//-->
<!--AUTHOR=Stephen Asbury//-->
<!--AUTHOR=Scott R. Weiner//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=20//-->
<!--PAGES=551-555//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="20-16.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="../ch21/21-01.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>The main method creates a TopicPublisherTest and displays it.
</P>
<!-- CODE //-->
<PRE>
    public static void main(String s[])
    {
        JFrame frame;
        TopicPublisherTest panel;
        String user=&#147;TopicPublisherTest&#148;;

        if(s.length&gt0) user = s[0];

        frame = new JFrame(user);

        panel = new TopicPublisherTest(user);

        //So we can catch errors in a log file
        System.setErr(System.out);

        frame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
        frame.setForeground(Color.black);
        frame.setBackground(Color.lightGray);
        frame.getContentPane().add(panel,&#147;Center&#148;);

        frame.pack();
        frame.setVisible(true);
        frame.addWindowListener(new WindowCloser(panel));
    }
}
</PRE>
<!-- END CODE //-->
<P>WindowCloser is a convenience class that handles the window close box.
</P>
<!-- CODE //-->
<PRE>
class WindowCloser extends WindowAdapter
{
    TopicPublisherTest test;

    public WindowCloser(TopicPublisherTest test)
    {
        this.test = test;
    }

    public void windowClosing(WindowEvent e)
    {

        Window win = e.getWindow();
        test.close();
        win.setVisible(false);
        System.exit(0);
    }
}
</PRE>
<!-- END CODE //-->
<P>As you can see, a TopicPublisher is very similar to a QueueSender; the only real changes are the underlying model and the vocabulary. The next section discusses how a program can receive messages for a topic. Although similar to receiving messages from a queue, receiving topic subscribers has the added option of being nonpersistent.
</P>
<H4 ALIGN="LEFT"><A NAME="Heading27"></A><FONT COLOR="#000077">The Topic Subscriber</FONT></H4>
<P>TopicSubscriber adds two methods to the MessageConsumer interface. These are:
</P>
<!-- CODE SNIP //-->
<PRE>
public boolean getNoLocal() throws JMSException
public Topic getTopic() throws JMSException
</PRE>
<!-- END CODE SNIP //-->
<P>The noLocal flag indicates whether or not the subscriber should receive messages from its own client. The getTopic method simply returns the subscriber&#146;s associated topic.
</P>
<P>The CD-ROM contains an example, called TopicSubscriber test, that is nearly identical to the QueueReceiverTest. The main difference is that TopicSubscriber uses Topic-based API rather than Queue-based API.</P>
<P>Another example on the CD-ROM, called DurableSubscriberTest, creates a durable subscriber rather than a transient one. If you run both the SubscriberTest and DurableSubscriber test examples, you will notice only one real difference between them. If the durable subscriber is exited before several messages are sent, and then it is restarted, it will receive the messages that it missed. The normal subscriber in this situation will simply miss the messages with no notification that they even occurred.</P>
<H4 ALIGN="LEFT"><A NAME="Heading28"></A><FONT COLOR="#000077">The TopicRequester Utility Class</FONT></H4>
<P>JMS provides a class called TopicRequester that encapsulates the code used to send a message and receive a reply. This requester object creates a temporary topic and handles the message-receiving code. To use the requestor, create it with a Topic and a TopicSession. Then use the method:
</P>
<!-- CODE SNIP //-->
<PRE>
public Message request(Message message) throws JMSException
</PRE>
<!-- END CODE SNIP //-->
<P>to send messages and wait for the reply.
</P>
<H3><A NAME="Heading29"></A><FONT COLOR="#000077">Distributed Transactions and JMS Providers</FONT></H3>
<P>JMS supports the use of distributed transactions via the JTA interfaces. These distributed transactions, as discussed in Chapter 22, &#147;Transactions, JTA, and JTS,&#148; allow multiple programs to share the same transaction scope. Distributed transactions can be complex and resource intensive. In order to allow programs to choose between JMS with distributed transactions and without, the classes for supporting transactions are separate from the nontransacted versions. These classes, listed in Table 20.13, all have an XA prefix for their name and duplicate the classes used for normal JMS.
</P>
<P>Keep in mind that the distributed transactions are related to the Sessions transactions but are not required to support Session transactions. The XASession object provides a method called:</P>
<!-- CODE SNIP //-->
<PRE>
public javax.transaction.xa.XAResource getXAResource()
</PRE>
<!-- END CODE SNIP //-->
<P>that returns the XAResource defined in JTA for transaction management. The XAQueueSession and XATopicSession extend XASession and provide methods for accessing the actual QueueSession and TopicSession, respectively.
</P>
<TABLE WIDTH="100%"><TR>
<TD CAPTION ALIGN="LEFT" COLSPAN="3"><B>Table 20.13</B> JMS XA Classes
<TR>
<TD COLSPAN="3"><HR>
<TR>
<TH VALIGN="TOP" WIDTH="20%" ALIGN="LEFT">JMS ROOT
<TH VALIGN="TOP" WIDTH="40%" ALIGN="LEFT">POINT-TO-POINT<BR>MESSAGING
<TH VALIGN="TOP" ALIGN="LEFT">PUBLISH-SUBSCRIBE<BR>MESSAGING
<TR>
<TD COLSPAN="3"><HR>
<TR>
<TD VALIGN="TOP" ALIGN="LEFT"><SMALL>XAConnection-Factory</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT"><SMALL>XAQueueConnection-Factory</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT"><SMALL>XATopicConnection-Factory</SMALL>
<TR>
<TD COLSPAN="3"><HR>
<TR>
<TD VALIGN="TOP" ALIGN="LEFT"><SMALL>XAConnection</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT"><SMALL>XAQueueConnection</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT"><SMALL>XATopicConnection</SMALL>
<TR>
<TD COLSPAN="3"><HR>
<TR>
<TD VALIGN="TOP" ALIGN="LEFT"><SMALL>XASession</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT"><SMALL>XAQueueSession</SMALL>
<TD VALIGN="TOP" ALIGN="LEFT"><SMALL>XATopicSession</SMALL>
<TR>
<TD COLSPAN="3"><HR>
</TABLE>
<BLOCKQUOTE>
<P><FONT SIZE="-1"><HR><B>NOTE:&nbsp;&nbsp;</B>MiniJMS does not support the XA version of the JMS classes.
</FONT><HR>
</BLOCKQUOTE>
<P>As mentioned throughout this chapter, portions of the JMS specification are not designed for client use. Rather, these interfaces and methods are designed for use by application servers that host a JMS provider. These classes include the ConnectionConsumer that a Connection can create as well as the ServerSession and ServerSessionPool interfaces. Because this chapter is not intended for JMS provider implementers, these interfaces were not covered in detail. However, Chapter 26 does implement the client interfaces without this Application Server support. We made this separation in our implementation because we did not intend for a server to host our provider. In fact, the specification implies that a server must host the JMS provider, and we wanted to show that this is not the case.
</P>
<H3><A NAME="Heading30"></A><FONT COLOR="#000077">Summary</FONT></H3>
<P>The Java Messaging Service, JMS, defines an API for sending messages between applications. JMS messages can be persistent and guaranteed, ensuring their delivery or at least ensuring that they are delivered if the libraries say they will be. JMS is organized into two types of messaging and their associated APIs. Point-to-point messaging uses queues to handle the transfer of messages from potentially multiple clients to a single receiver. Publish-subscribe messaging allows many clients to communicate and share messages on a named set of topics. To use JMS, you must first acquire an implementation of the specification from a JMS provider. This implementation provides the classes that implement the interfaces discussed in this chapter.
</P>
<P>The messages the JMS defines are all represented by objects that have headers for configuration, properties for application, and provider-specific information and a body for content. To send a message:</P>
<DL>
<DD><B>1.</B>&nbsp;&nbsp;Retrieve a ConnectionFactory from JNDI.
<DD><B>2.</B>&nbsp;&nbsp;Retrieve the Destinations of interest from JNDI.
<DD><B>3.</B>&nbsp;&nbsp;Use the ConnectionFactory to create a Connection to the JMS provider, probably to the server.
<DD><B>4.</B>&nbsp;&nbsp;Use the Connection to create a Session.
<DD><B>5.</B>&nbsp;&nbsp;Use the Session and Destination objects to create MessageConsumers, MessageProducers, or both.
<DD><B>6.</B>&nbsp;&nbsp;Assign any MessageListeners.
<DD><B>7.</B>&nbsp;&nbsp;Send messages with the producer, receive messages with the consumer.
</DL>
<P>Given the simplicity of sending messages and the power of a persistent delivery mechanism, JMS and the providers that implement it are a powerful addition to the enterprise Java programmer&#146;s tool kit. The next chapter combines the techniques discussed in this chapter to create a set of three programs that communicate via messaging to create a single application.
</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="20-16.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="../ch21/21-01.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>


<!-- 