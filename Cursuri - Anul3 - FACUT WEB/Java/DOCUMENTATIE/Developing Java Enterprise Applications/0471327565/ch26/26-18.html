
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
	',height=' + height + ',resizable=1,scrollbars=yes');
	}
	//-->
	</SCRIPT>



<FONT FACE="Arial,Helvetica" SIZE="-1">
To access the contents, click the chapter and section titles.
</FONT>
<P>
<B>Developing Java Enterprise Applications</B>
<FONT SIZE="-1">
<BR>
<I>(Publisher: John Wiley & Sons, Inc.)</I>
<BR>
Author(s): Stephen Asbury ; Scott R. Weiner
<BR>
ISBN: 0471327565
<BR>
Publication Date: 02/01/99
</FONT>
<P>
<Script language="JavaScript">
function isIE4() 
{
    return( navigator.appName.indexOf("Microsoft") != -1 && (navigator.appVersion.charAt(0)=='4') );
 }
function bookMarkit()
{
        var url="http://www.itknowledge.com/PSUser/EWBookMarks.html?url="+window.location+"&isbn=0";
	parent.location.href=url;
        //var win = window.open(url,"myitk");
        //if(!isIE4())
        //       win.focus();

}
</Script>
<a href="javascript:bookMarkit();"><img src="/images/bookmarkit.gif" border=0 alt="Bookmark It" width=97 height=23></a>

<P>
<form name="Search" method="GET" action="http://search.earthweb.com/search97/search_redir.cgi">

<INPUT TYPE="hidden" NAME="Action" VALUE="Search">
<INPUT TYPE="hidden" NAME="SearchPage" VALUE="http://search.earthweb.com/search97/samples/forms/srchdemo.htm">
<INPUT TYPE="hidden" NAME="Collection" VALUE="ITK">
<INPUT TYPE="hidden" NAME="ResultTemplate" VALUE="itk-simple-intrabook.hts">
<INPUT TYPE="hidden" NAME="ViewTemplate" VALUE="view.hts">

<font face="arial, helvetica" size=2><b>Search this book:</b></font><br>
<INPUT NAME="queryText" size=50 VALUE="">&nbsp;<input type="submit" name="submitbutton" value="Go!">
<INPUT type=hidden NAME="section_on" VALUE="on">
<INPUT type=hidden NAME="section" VALUE="http://www.itknowledge.com/reference/standard/0471327565/">

</form>


<!-- Empty Reference Subhead -->

<!--ISBN=0471327565//-->
<!--TITLE=Developing Java Enterprise Applications//-->
<!--AUTHOR=Stephen Asbury//-->
<!--AUTHOR=Scott R. Weiner//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=26//-->
<!--PAGES=746-751//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="26-17.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="26-19.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>Closing the session using the close method stops the thread used to poll the message store. Then, if it is transacted, the session rolls back in case there is an uncommitted transaction. Finally, all temporary subscriptions are unregistered with the store. Temporary destinations are also deleted from the store.
</P>
<!-- CODE //-->
<PRE>
    public RemoteMiniSession close()
     throws RemoteException, JMSException
    {
        try
        {
            Object[] unreg;
            Destination dest;

            <B>checker.stop();

            if(transacted)//rollback the uncommited trans
                rollback();</B>

            int i,max;

            max = unregOnClose.size();

            for(i=0;i&ltmax;i&#43;&#43;)
            {
                unreg = (Object[]) unregOnClose.elementAt(i);

                <B>dest = (Destination)unreg[0];

                unregisterFor(dest,(String)unreg[1]);

                if((dest instanceof TemporaryTopic)
                    ||(dest instanceof TemporaryQueue))
                {
                    store.deleteDestination(dest.toString());
                }</B>
            }
        }
        catch(Exception ignore)
        {
        }

        return null;
    }
</PRE>
<!-- END CODE //-->
<P>The remote session provides an interface, listed here, for the client to the store for creating queues, topics, and deleting destinations. All exceptions are simply passed through from the store to the client.
</P>
<!-- CODE //-->
<PRE>
    //Throws an exception if one exists.
    public Queue createQueue(String queueName)
     throws RemoteException, JMSException
    {
        return store.createQueue(queueName);
    }

    //Throws an exception if one exists.
    public Topic createTopic(String queueName)
     throws RemoteException, JMSException
    {
        return store.createTopic(queueName);
    }

    public void deleteDestination(String queueName)
     throws RemoteException, JMSException
    {
        store.deleteDestination(queueName);
    }
</PRE>
<!-- END CODE //-->
<P>When a session is asked to send a message, it either stores the message for sending or sends it, depending on its transacted state. Non-transacted sessions send immediately. Transacted sessions delay sending until the commit method is called.
</P>
<!-- CODE //-->
<PRE>
    public void send(Message message)
                 throws RemoteException, JMSException
    {
        if(transacted)
        {
            synchronized(toSend)
            {
                toSend.addElement(message);
            }
        }
        else
        {
            reallySend(message);
        }
    }
</PRE>
<!-- END CODE //-->
<P>Really sending a message, using the reallySend method, involves passing it to the message store. Any exceptions are converted to JMS exceptions to comply with the JMS specification.
</P>
<!-- CODE //-->
<PRE>
    protected void reallySend(Message message)
        throws JMSException
    {
        try
        {
            //Send message to store.
            //May use persistant store if appropriate.
            store.send(message);
        }
        catch(JMSException exp)
        {
            throw exp;
        }
        catch(Exception exp)
        {
            throw new JMSException(&#147;Failed to send message.&#148;);
        }
    }
</PRE>
<!-- END CODE //-->
<P>Committing a transacted remote session causes it to send any messages in the toSend vector. The session also clears out the histories vectors and acknowledges the messages in them; only the message with the highest number is acknowledged. Committing a non-transacted session has no effect. The complete code for commit is listed here:
</P>
<!-- CODE //-->
<PRE>
    public void commit() throws JMSException
    {
        if(!transacted) return;

        int i,max;
        Message msg;
        long num=-1;

        try
        {
            synchronized(toSend)
            {
                max = toSend.size();

                for(i=0;i&ltmax;i&#43;&#43;)
                {
                    msg = (Message) toSend.elementAt(i);
                    reallySend(msg);
                }

                toSend.removeAllElements();
            }

            synchronized(histories)
            {
                Enumeration cursor = histories.keys();
                Vector history;
                HistoryPair pair;

                while(cursor.hasMoreElements())
                {
                    pair = (HistoryPair) cursor.nextElement();
                    history = (Vector) histories.get(pair);

                    max = history.size();

                    for(i=0;i&ltmax;i&#43;&#43;)
                    {
                        msg = (Message) history.elementAt(i);

                        if(msg.propertyExists(
                            MiniJMSMessageStore.MSG_NUM))
                        {
                            num = Math.max(num
                                    ,msg.getLongProperty(
                                      MiniJMSMessageStore.MSG_NUM));
                        }
                    }

                    history.removeAllElements();

                    //Acknowledge as a whole when transacted.
                    if(num&gt0)
                        store.acknowledge(pair.destination
                      ,pair.name,num);
                }
            }
        }
        catch(Exception exp)
        {
            throw new JMSException(exp.toString());
        }
    }
</PRE>
<!-- END CODE //-->
<P>Rolling back a transacted session removes all of the pending sends in the toSend vector and calls the internal method reallyRecover, discussed here. Recover calls the same method with a different argument. This argument tells the session whether the recovered messages should be marked as redelivered.
</P>
<!-- CODE //-->
<PRE>
    public void rollback() throws JMSException
    {
        if(!transacted) return;
        toSend.removeAllElements();//throw away sends
        reallyRecover(false);
    }

    public void recover() throws JMSException
    {
        if(transacted) return;
        else reallyRecover(true);
    }
</PRE>
<!-- END CODE //-->
<P>Both rollback and recover call the reallyRecover method listed here. This method takes messages from the histories vectors and resends them using addMessage. This causes them to be redelivered if the client is still available.
</P>
<!-- CODE //-->
<PRE>
    //tf == true -&gt mark redelivered
    protected void reallyRecover(boolean tf) throws JMSException
    {
        try
        {
            synchronized(histories)
            {
                Enumeration cursor = histories.keys();
                Vector history;
                Destination d;
                int i,max;
                Message msg;
                HistoryPair pair;
                String name;

                while(cursor.hasMoreElements())
                {
                    pair = (HistoryPair) cursor.nextElement();
                    history = (Vector) histories.get(pair);

                    d = pair.destination;
                    name = pair.name;

                    max = history.size();

                    for(i=0;i&ltmax;i&#43;&#43;)
                    {
                        msg = (Message) history.elementAt(i);

                        if(tf) msg.setJMSRedelivered(true);

                        addMessage(msg);
                    }

                    history.removeAllElements();
                }
            }
        }
        catch(Exception exp)
        {
            throw new JMSException(&#147;Failed to recover completely.&#148;);
        }
    }
</PRE>
<!-- END CODE //-->
<P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="26-17.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="26-19.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>


<!-- 