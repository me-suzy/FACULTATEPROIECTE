
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
	',height=' + height + ',resizable=1,scrollbars=yes');
	}
	//-->
	</SCRIPT>



<FONT FACE="Arial,Helvetica" SIZE="-1">
To access the contents, click the chapter and section titles.
</FONT>
<P>
<B>Developing Java Enterprise Applications</B>
<FONT SIZE="-1">
<BR>
<I>(Publisher: John Wiley & Sons, Inc.)</I>
<BR>
Author(s): Stephen Asbury ; Scott R. Weiner
<BR>
ISBN: 0471327565
<BR>
Publication Date: 02/01/99
</FONT>
<P>
<Script language="JavaScript">
function isIE4() 
{
    return( navigator.appName.indexOf("Microsoft") != -1 && (navigator.appVersion.charAt(0)=='4') );
 }
function bookMarkit()
{
        var url="http://www.itknowledge.com/PSUser/EWBookMarks.html?url="+window.location+"&isbn=0";
	parent.location.href=url;
        //var win = window.open(url,"myitk");
        //if(!isIE4())
        //       win.focus();

}
</Script>
<a href="javascript:bookMarkit();"><img src="/images/bookmarkit.gif" border=0 alt="Bookmark It" width=97 height=23></a>

<P>
<form name="Search" method="GET" action="http://search.earthweb.com/search97/search_redir.cgi">

<INPUT TYPE="hidden" NAME="Action" VALUE="Search">
<INPUT TYPE="hidden" NAME="SearchPage" VALUE="http://search.earthweb.com/search97/samples/forms/srchdemo.htm">
<INPUT TYPE="hidden" NAME="Collection" VALUE="ITK">
<INPUT TYPE="hidden" NAME="ResultTemplate" VALUE="itk-simple-intrabook.hts">
<INPUT TYPE="hidden" NAME="ViewTemplate" VALUE="view.hts">

<font face="arial, helvetica" size=2><b>Search this book:</b></font><br>
<INPUT NAME="queryText" size=50 VALUE="">&nbsp;<input type="submit" name="submitbutton" value="Go!">
<INPUT type=hidden NAME="section_on" VALUE="on">
<INPUT type=hidden NAME="section" VALUE="http://www.itknowledge.com/reference/standard/0471327565/">

</form>


<!-- Empty Reference Subhead -->

<!--ISBN=0471327565//-->
<!--TITLE=Developing Java Enterprise Applications//-->
<!--AUTHOR=Stephen Asbury//-->
<!--AUTHOR=Scott R. Weiner//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=26//-->
<!--PAGES=709-714//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="26-08.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="26-10.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>A number of methods, defined in the following code, are provided to the MiniJMS client classes for registering with the session. All of these result in a call to the MiniRemoteSession.
</P>
<!-- CODE //-->
<PRE>
    public void registerFor(Destination dest)
        throws JMSException
    {
        registerFor(dest,true,conn.getClientID());
    }

    public void registerFor(Destination dest,String name)
        throws JMSException
    {
        registerFor(dest,true,name);
    }

    public void registerFor(Destination dest,boolean durable)
        throws JMSException
    {
        registerFor(dest,durable,conn.getClientID());
    }

    public void registerFor(Destination dest
                             , boolean durable,String name)
        throws JMSException
    {
        try
        {
            <B>session.registerFor(dest,true,name);</B>
        }
        catch(Exception exp)
        {
            throw new JMSException(exp.toString());
        }
    }

    public void unregisterFor(Destination dest)
        throws JMSException
    {
        unregisterFor(dest,conn.getClientID());
    }

    public void unregisterFor(Destination dest,String name)
        throws JMSException
    {
        try
        {
            <B>session.unregisterFor(dest,name);</B>
        }
        catch(Exception exp)
        {
            throw new JMSException(exp.toString());
        }
    }
</PRE>
<!-- END CODE //-->
<P>When a connection is told to stop and start, it sends suspend and resume to the sessions. Currently, these messages are ignored.
</P>
<!-- CODE SNIP //-->
<PRE>
    public void suspend()
    {
    }

    public void resume()
    {
    }
}
</PRE>
<!-- END CODE SNIP //-->
<P>MiniSession is the key element in the client implementation for MiniJMS. Make sure that you are comfortable with its implementation and purpose before continuing with the material in this chapter.
</P>
<H4 ALIGN="LEFT"><A NAME="Heading10"></A><FONT COLOR="#000077">MiniConsumer</FONT></H4>
<P>Rather than implement separate consumers for the two messaging models, MiniJMS implements a single consumer that supports both. MiniConsumer is a MessageConsumer, TopicSubscriber, and QueueReceiver. Because MiniDestinations are both queues and topics, the consumer can use a single destination object to represent its associated destination.
</P>
<P>A MiniConsumer tracks its session, a MessageListener, its destination, selector, and registered name. This name is the same one used to register with the session and will default to the connection&#146;s ClientID. The Boolean variable noLocal is used by the consumer to remember if it should ignore messages from the connection that it is attached to; currently, MiniJMS ignores the value of this flag. The Boolean variable unregOnClose is used by the consumer to remember whether it is durable or not. If this value is true, the consumer will unregister with the server when it is closed.</P>
<BLOCKQUOTE>
<P><FONT SIZE="-1"><HR><B>NOTE:&nbsp;&nbsp;</B>MiniJMS does not support selectors or the noLocal feature.</FONT><HR>
</BLOCKQUOTE>
<!-- CODE //-->
<PRE>
package minijms;

//Imports removed to save space.
public class MiniConsumer
 implements MessageConsumer
 , TopicSubscriber, QueueReceiver
{
    protected MessageListener listener;
    protected MiniSession session;
    protected MiniDestination dest;
    protected String selector;
    protected boolean noLocal;
    protected boolean unregOnClose;
    protected String regName;

    public MiniConsumer(MiniSession session
                            ,MiniDestination dest)
    {
        this.session = session;
        this.dest = dest;
        noLocal = false;
        unregOnClose = false;
    }
</PRE>
<!-- END CODE //-->
<P>When a MiniConsumer is closed, it notifies the session in two ways. First, if it is a non-durable consumer, it unregisters its destination. Second, by setting its MessageListener to null, MiniConsumer tells the session to remove the MessageListener from its list.
</P>
<!-- CODE SNIP //-->
<PRE>
    public void close()
      throws JMSException
    {
        if(unregOnClose) session.unregisterFor(dest);
        setMessageListener(null);
    }
</PRE>
<!-- END CODE SNIP //-->
<P>The following accessors are provided for the message selector, registered name, and MessageListener.
</P>
<!-- CODE //-->
<PRE>
    public String getMessageSelector() throws JMSException
    {
        return selector;
    }

    public void setMessageSelector(String s)
     throws JMSException
    {
        selector = s;
    }

    public MessageListener getMessageListener()
     throws JMSException
    {
        return listener;
    }

    public void setMessageListener(MessageListener lst)
        throws JMSException
    {
        if(listener != null)
        {
            session.removeMessageListenerFor(listener,dest);
        }

        listener = lst;

        if(listener != null)
            session.addMessageListenerFor(listener,dest,regName);
    }

    public String getRegName()
    {
        return regName;
    }

    public void setRegName(String name)
    {
        regName = name;
    }

    protected void setNoLocal(boolean b)
    {
        noLocal = b;
    }

    public boolean getNoLocal() throws JMSException
    {
        return noLocal;
    }
</PRE>
<!-- END CODE //-->
<P>Consumers provide three methods for receiving messages directly, defined as follows. These methods call the equivalent methods in the MiniSession object.
</P>
<!-- CODE //-->
<PRE>
    public Message receive()
     throws JMSException
    {
        Message retVal = null;

        try
        {
            <B>retVal = session.messageFor(dest,regName);</B>
        }
        catch(JMSException exp)
        {
            throw exp;
        }
        catch(Exception exp)
        {
            throw new JMSException(&#147;No remote connection.&#148;);
        }

        return retVal;
    }

    public Message receive(long timeOut)
     throws JMSException
    {
        Message retVal = null;

        try
        {
            <B>retVal = session.messageFor(dest,timeOut,regName);</B>
        }
        catch(Exception exp)
        {
            throw new JMSException(&#147;No remote connection.&#148;);
        }

        return retVal;
    }

    public Message receiveNoWait()
     throws JMSException
    {
        Message retVal = null;

        try
        {
            <B>retVal = session.messageForNoWait(dest,regName);</B>
        }
        catch(JMSException exp)
        {
            throw exp;
        }
        catch(Exception exp)
        {
            throw new JMSException(&#147;No remote connection.&#148;);
        }

        return retVal;
    }
</PRE>
<!-- END CODE //-->
<P>TopicSubscribers and QueueReceivers both provide type-specific access to their destination. The MiniConsumer implements both methods, as shown here, and throws an exception if the wrong one is used.
</P>
<!-- CODE //-->
<PRE>
    public Queue getQueue() throws JMSException
    {
        if(dest.isQueue()) return dest;
        else throw new JMSException();
    }

    public Topic getTopic() throws JMSException
    {
        if(!dest.isQueue()) return dest;
        else throw new JMSException();
    }

    public void setUnregisterOnClose(boolean tf)
    {
        unregOnClose=tf;
    }
}
</PRE>
<!-- END CODE //-->
<P>As you can see, the consumer in MiniJMS is mainly a front for the session, providing the basic information required to specify the destination and name for requests.
</P>
<H4 ALIGN="LEFT"><A NAME="Heading11"></A><FONT COLOR="#000077">MiniProducer</FONT></H4>
<P>Like the MiniConsumer, the MiniProducer implements all three of the producer interfaces: MessageProducer, TopicPublisher, and QueueSender. The producer keeps a reference to its session for performing the actual message sending. Configuration parameters for a producer include the default delivery mode, default priority, and default timeToLive for messages. Flags are used to indicate whether a message ID and time stamp are required for each message sent.
</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="26-08.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="26-10.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>


<!-- 