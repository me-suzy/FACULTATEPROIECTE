
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
	',height=' + height + ',resizable=1,scrollbars=yes');
	}
	//-->
	</SCRIPT>



<FONT FACE="Arial,Helvetica" SIZE="-1">
To access the contents, click the chapter and section titles.
</FONT>
<P>
<B>Developing Java Enterprise Applications</B>
<FONT SIZE="-1">
<BR>
<I>(Publisher: John Wiley & Sons, Inc.)</I>
<BR>
Author(s): Stephen Asbury ; Scott R. Weiner
<BR>
ISBN: 0471327565
<BR>
Publication Date: 02/01/99
</FONT>
<P>
<Script language="JavaScript">
function isIE4() 
{
    return( navigator.appName.indexOf("Microsoft") != -1 && (navigator.appVersion.charAt(0)=='4') );
 }
function bookMarkit()
{
        var url="http://www.itknowledge.com/PSUser/EWBookMarks.html?url="+window.location+"&isbn=0";
	parent.location.href=url;
        //var win = window.open(url,"myitk");
        //if(!isIE4())
        //       win.focus();

}
</Script>
<a href="javascript:bookMarkit();"><img src="/images/bookmarkit.gif" border=0 alt="Bookmark It" width=97 height=23></a>

<P>
<form name="Search" method="GET" action="http://search.earthweb.com/search97/search_redir.cgi">

<INPUT TYPE="hidden" NAME="Action" VALUE="Search">
<INPUT TYPE="hidden" NAME="SearchPage" VALUE="http://search.earthweb.com/search97/samples/forms/srchdemo.htm">
<INPUT TYPE="hidden" NAME="Collection" VALUE="ITK">
<INPUT TYPE="hidden" NAME="ResultTemplate" VALUE="itk-simple-intrabook.hts">
<INPUT TYPE="hidden" NAME="ViewTemplate" VALUE="view.hts">

<font face="arial, helvetica" size=2><b>Search this book:</b></font><br>
<INPUT NAME="queryText" size=50 VALUE="">&nbsp;<input type="submit" name="submitbutton" value="Go!">
<INPUT type=hidden NAME="section_on" VALUE="on">
<INPUT type=hidden NAME="section" VALUE="http://www.itknowledge.com/reference/standard/0471327565/">

</form>


<!-- Empty Reference Subhead -->

<!--ISBN=0471327565//-->
<!--TITLE=Developing Java Enterprise Applications//-->
<!--AUTHOR=Stephen Asbury//-->
<!--AUTHOR=Scott R. Weiner//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=21//-->
<!--PAGES=565-568//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="21-02.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="21-04.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>The method loadAlarms, included below, loads a vector from disk and reads the Alarm objects contained in this vector. Each alarm is associated with a PTimerSpec and placed in the two hash tables. The PTimerSpec is scheduled with the PTimer so it will notify the server if it is fired.
</P>
<!-- CODE //-->
<PRE>
    protected void loadAlarms()
    {
        FileInputStream fileIn;//Stream for reading
        BufferedInputStream bufIn;//Stream for reading
        ObjectInputStream objIn;//Stream for reading
        String fileName;//File to read
        Vector readFrom;//Vector read from file
        Alarm alarm;//temp variable
        int i,max;//temp variable
        long now= System.currentTimeMillis();
        long alarmTime;//temp variable
        PTimer timer = PTimer.getTimer();//shared PTimer
        PTimerSpec spec;//temp variable
       
        try
        {
            fileName
                = MiniJMSUtils.properties.getProperty(&#147;alarmfile&#148;);
            fileIn = new FileInputStream(fileName);
            bufIn = new BufferedInputStream(fileIn);
            objIn = new ObjectInputStream(bufIn);
       
            readFrom = (Vector) objIn.readObject();
       
            objIn.close();
           
            max = readFrom.size();
           
            for(i=0;i&ltmax;i&#43;&#43;)
            {
                alarm = (Alarm) readFrom.elementAt(i);
                alarmTime
                 = dateFormat.parse(alarm.getTime()).getTime();
                
                 if(alarmTime &gt now)
                 {
                    spec = new PTimerSpec();
                    spec.setAbsoluteTime(alarmTime);
                    spec.addPTimerWentOffListener(this);

                    timers.put(spec,alarm);
                    alarm2timer.put(alarm,spec);
       
                    timer.schedule(spec);
                 }
            }
        }
        catch(Exception exp)
        {
            exp.printStackTrace();
        }
    }
</PRE>
<!-- END CODE //-->
<P>The saveAlarms method reverses the loadAlarms process by creating a vector of Alarm objects and serializing it to disk. In this case, no changes are made to the existing alarms or their PTimerSpecs.
</P>
<!-- CODE //-->
<PRE>
    protected void saveAlarms()
    {
        FileOutputStream fileOut;
        BufferedOutputStream bufOut;
        ObjectOutputStream objOut;
        String fileName;
        Vector toWrite = new Vector();
        Enumeration cursor;
       
        try
        {
            cursor = alarm2timer.keys();
       
            while(cursor.hasMoreElements())
            {
                toWrite.addElement(cursor.nextElement());
            }

            fileName
                = MiniJMSUtils.properties.getProperty(&#147;alarmfile&#148;);
            fileOut = new FileOutputStream(fileName);
            bufOut = new BufferedOutputStream(fileOut);
            objOut = new ObjectOutputStream(bufOut);
       
            objOut.writeObject(toWrite);
       
            objOut.close();
        }
        catch(Exception exp)
        {
            exp.printStackTrace();
        }
    }
</PRE>
<!-- END CODE //-->
<P>The main method for AlarmServer creates an AlarmServer object, associates a thread with it, and starts the thread running. This background thread checks for messages on the ADMIN_QUEUE. When a message arrives, the server casts it to a MapMessage. If this fails, the server goes back to checking for messages after printing a stack trace. If the cast succeeds, the server checks the value of the ACTION key. This value is used to call an internal message in AlarmServer to handle the request. For example, the SET action triggers a call to handleSet. The implementation for the AlarmServer&#146;s run method is as follows:
</P>
<!-- CODE //-->
<PRE>
    public void run()
    {
        Message msg=null;
               
        while(true)
        {
            try
            {
                MapMessage map;
                String action;

                <B>msg = adminReceiver.receive();
               
                map = (MapMessage) msg;
                action = map.getString(ACTION);
           
                if(SET.equals(action))
                {
                    handleSet(map);
                }</B>
                else if(DELETE.equals(action))
                {
                    handleDelete(map);
                }
                else if(GET_ALARMS.equals(action))
                {
                    handleGet(map);
                }
                else if(SHUTDOWN.equals(action))
                {
                    handleShutdown(map);
                }
            }
            catch(Exception exp)
            {
                exp.printStackTrace();
            }
        }
    }
</PRE>
<!-- END CODE //-->
<P>A request to set an alarm requires that the ALARM key in the MapMessage contains an Alarm object. If this is not the case, an exception is thrown, exiting the handleSet method and catching in the run method.
</P>
<P>If an alarm is provided, the alarm&#146;s time is parsed and a new PTimerSpec is created using the alarm&#146;s time. This spec and the alarm are added to the timers and alarm2timer hash tables, and the spec is scheduled. The AlarmServer sets itself up as a PTimerWentOffListener for all of the timer specs in the system to receive notification of an alarm.</P>
<P>Whenever an alarm is added or deleted, the server uses the handleGet method shown below to publish a message containing the new, complete list of alarms. This message is used by the AlarmConfig program to keep its list up to date.</P>
<!-- CODE //-->
<PRE>
    protected void handleSet(MapMessage msg)
        throws Exception
    {
        Alarm alarm = (Alarm) msg.getObject(ALARM);
        String name;
        long alarmTime;
        PTimer timer = PTimer.getTimer();
        PTimerSpec spec = new PTimerSpec();
       
        name = alarm.getName();
       
        alarmTime = dateFormat.parse(alarm.getTime()).getTime();
       
        spec.setAbsoluteTime(alarmTime);
        spec.addPTimerWentOffListener(this);

        synchronized(timers)
        {       
            timers.put(spec,alarm);
            alarm2timer.put(alarm,spec);
        }
       
        timer.schedule(spec);
       
        handleGet(null);
    }
</PRE>
<!-- END CODE //-->
<P>When a delete request is received, the server removes the timer spec and Alarm object from its hash tables and deschedules the PTimerSpec. This tells the PTimer to stop watching for that spec to fire. Finally, the handleGet method is used to notify listeners of the change.
</P>
<!-- CODE //-->
<PRE>
    protected void handleDelete(MapMessage msg)
        throws Exception
    {
        Alarm alarm = (Alarm) msg.getObject(ALARM);
        String name;
        PTimer timer = PTimer.getTimer();
        PTimerSpec spec;
       
        synchronized(timers)
        {  
            spec = (PTimerSpec) alarm2timer.get(alarm);
       
            timer.deschedule(spec);
       
            alarm2timer.remove(alarm);
            timers.remove(spec);
        }
       
        handleGet(null);
    }
</PRE>
<!-- END CODE //-->
<P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="21-02.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="21-04.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>


<!-- 