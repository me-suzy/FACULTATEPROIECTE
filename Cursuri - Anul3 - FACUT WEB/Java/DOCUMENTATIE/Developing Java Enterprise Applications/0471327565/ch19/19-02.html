
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
	',height=' + height + ',resizable=1,scrollbars=yes');
	}
	//-->
	</SCRIPT>



<FONT FACE="Arial,Helvetica" SIZE="-1">
To access the contents, click the chapter and section titles.
</FONT>
<P>
<B>Developing Java Enterprise Applications</B>
<FONT SIZE="-1">
<BR>
<I>(Publisher: John Wiley & Sons, Inc.)</I>
<BR>
Author(s): Stephen Asbury ; Scott R. Weiner
<BR>
ISBN: 0471327565
<BR>
Publication Date: 02/01/99
</FONT>
<P>
<Script language="JavaScript">
function isIE4() 
{
    return( navigator.appName.indexOf("Microsoft") != -1 && (navigator.appVersion.charAt(0)=='4') );
 }
function bookMarkit()
{
        var url="http://www.itknowledge.com/PSUser/EWBookMarks.html?url="+window.location+"&isbn=0";
	parent.location.href=url;
        //var win = window.open(url,"myitk");
        //if(!isIE4())
        //       win.focus();

}
</Script>
<a href="javascript:bookMarkit();"><img src="/images/bookmarkit.gif" border=0 alt="Bookmark It" width=97 height=23></a>

<P>
<form name="Search" method="GET" action="http://search.earthweb.com/search97/search_redir.cgi">

<INPUT TYPE="hidden" NAME="Action" VALUE="Search">
<INPUT TYPE="hidden" NAME="SearchPage" VALUE="http://search.earthweb.com/search97/samples/forms/srchdemo.htm">
<INPUT TYPE="hidden" NAME="Collection" VALUE="ITK">
<INPUT TYPE="hidden" NAME="ResultTemplate" VALUE="itk-simple-intrabook.hts">
<INPUT TYPE="hidden" NAME="ViewTemplate" VALUE="view.hts">

<font face="arial, helvetica" size=2><b>Search this book:</b></font><br>
<INPUT NAME="queryText" size=50 VALUE="">&nbsp;<input type="submit" name="submitbutton" value="Go!">
<INPUT type=hidden NAME="section_on" VALUE="on">
<INPUT type=hidden NAME="section" VALUE="http://www.itknowledge.com/reference/standard/0471327565/">

</form>


<!-- Empty Reference Subhead -->

<!--ISBN=0471327565//-->
<!--TITLE=Developing Java Enterprise Applications//-->
<!--AUTHOR=Stephen Asbury//-->
<!--AUTHOR=Scott R. Weiner//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=19//-->
<!--PAGES=492-495//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="19-01.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="../ch20/20-01.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>The defining factor in this model is that there may be multiple senders and receivers. It is not necessary that the programs act as both, only that the systems support both. An example of publish-subscribe messaging is pictured in Figure 19.4.
</P>
<P><A NAME="Fig3"></A><A HREF="javascript:displayWindow('images/19-03.jpg',500,158 )"><IMG SRC="images/19-03t.jpg"></A>
<BR><A HREF="javascript:displayWindow('images/19-03.jpg',500,158)"><FONT COLOR="#000077"><B>Figure 19.3</B></FONT></A>&nbsp;&nbsp;Queue-based messaging.</P>
<P><A NAME="Fig4"></A><A HREF="javascript:displayWindow('images/19-04.jpg',500,158 )"><IMG SRC="images/19-04t.jpg"></A>
<BR><A HREF="javascript:displayWindow('images/19-04.jpg',500,158)"><FONT COLOR="#000077"><B>Figure 19.4</B></FONT></A>&nbsp;&nbsp;Publish-subscribe messaging.</P>
<H4 ALIGN="LEFT"><A NAME="Heading3"></A><FONT COLOR="#000077">Request-Reply Messaging</FONT></H4>
<P><I>Request-reply messaging</I> is the standard object-messaging format. In this case, a program sends a message and expects to receive a message in return. Often, this messaging domain is defined as a subset of one of the other two. For example, a point-to-point system can support, publish, and subscribe by making both points sender and receiver. In our HR example, the HR system might send a message to the facilities system&#146;s queue requesting a new phone number and receive a message containing the new number.</P>
<P>JMS doesn&#146;t specifically support request-reply messaging, although it does allow it in the context of the other methods via the use of a &#147;reply to&#148; field in a message. In JMS, you can reply to a message by checking for the replyTo field and sending a message to the queue or topic that it contains.</P>
<H4 ALIGN="LEFT"><A NAME="Heading4"></A><FONT COLOR="#000077">Applications of Messaging</FONT></H4>
<P>Messaging has gained popularity over the past few years because of its flexibility and the advantages it provides in a variety of applications, such as distributed programming, business integration, and notification.
</P>
<P>By definition, messaging is a form of distributed programming. However, messaging adds the level of abstraction generated by the concept of a message. Unlike distributed programming systems such as RMI or CORBA, messaging encapsulates the message being sent into its own publicly defined entity. Programs can change the message type in most messaging systems, making them very flexible. This abstraction also makes it possible to use messaging to link systems. For example, a C programmer could send and receive messages using function calls, while a Java programmer sends and receives messages using method calls. The messages can travel between these two programs without either client knowing the implementation language of the other. In fact, the implementation of one program could change and the other wouldn&#146;t need to know unless the message definition changed with it.</P>
<P>Messaging can also save network resources. Server-based messaging systems will usually require only a single network connection from the client to the server. This connection is used for all of the messages sent by the client, even if the messages are going to different destinations. The client can also use the same connection to receive messages from the server. This means that a set of four clients need only four network connections to communicate, instead of the six connections required to support direct client-to-client communication.</P>
<P>Distributed programming is often used to implement the notification systems used as examples in this book. This is one of the main applications of messaging. With persistent messaging, in which the server stores messages for clients that are not currently available, applications can be sure that their notifications are received, even if the receiver is currently unavailable. For example, a company might post important messages using publish-subscribe techniques. When a sales person returns from a trip and connects her computer to the network, any pending messages will be downloaded and the user notified. Although programmers could implement this persistence by hand, the messaging system can handle it for them, encapsulating the work behind a robust, well-tested interface.</P>
<P>Perhaps the hottest application of messaging is business integration. <I>Business integration</I> is defined by one system talking to another system. Realizing that these systems may be created with very different technologies, messaging is a powerful translator. The HR system could be a PeopleSoft system, while the financial system could be an Oracle one. A programmer could create adapters that tie these systems together through messaging. When a change occurs in PeopleSoft, the adapter would send a message to the financial adapter, which in turn would update Oracle. If the financial system changes to SAP, then the adapter changes, but the other systems remain the same. The messages become the interface definition for distributed computing.</P>
<H3><A NAME="Heading5"></A><FONT COLOR="#000077">Java Messaging Service</FONT></H3>
<P>The Java Messaging Service (JMS) is a Java messaging specification designed by a group of MOM providers and Sun. JMS defines a set of Java interfaces. JMS providers implement these interfaces for the programmer by layering the JMS interface on top of their messaging services. JMS defines both Queues and Topics, but it doesn&#146;t require the provider to implement both.
</P>
<P>The primary goal for JMS was to provide an interface to messaging that was complete enough to make it useful but not a conglomeration of all of the features provided by existing messaging products. Instead, it tries to maximize portability with as many features as possible. Ideally, the providers that implement JMS will do so in 100-percent pure Java to maximize portability, but this is not a requirement of the specification.</P>
<P>The primary features for JMS are as follows:</P>
<DL>
<DD><B>&#149;</B>&nbsp;&nbsp;JMS defines the concept of a destination as the target for a message. This destination can be a Queue or a Topic. Queues are used for point-to-point messaging; Topics are used for publish-subscribe messaging.
<DD><B>&#149;</B>&nbsp;&nbsp;JMS defines the concept of connection factories that create the connections to a JMS provider.
<DD><B>&#149;</B>&nbsp;&nbsp;Point-to-point and publish-subscribe messaging are implemented and defined by separate interfaces so that a provider doesn&#146;t have to support both.
<DD><B>&#149;</B>&nbsp;&nbsp;All of the provider&#146;s code is defined by interfaces in JMS, freeing the implementation from subclassing limitations.
<DD><B>&#149;</B>&nbsp;&nbsp;JMS supports distributed transactions.
</DL>
<P>Each of these features is discussed in more detail in Chapter 20, &#147;Programming with the Java Messaging Service.&#148; A number of companies provide MOM, many of which have signed up to provide a JMS interface to their products. To get a list of the current JMS partners, go to <A HREF="http://java.sun.com/products/jms.">http://java.sun.com/products/jms.</A></P>
<H4 ALIGN="LEFT"><A NAME="Heading6"></A><FONT COLOR="#000077">Summary</FONT></H4>
<P>Messaging is a great addition to the other programming techniques described in this book. Although it is not the be-all and end-all of distributed programming, messaging does provide many advantages in situations in which the programmer wants to decouple the implementation of the distributed programming from the interface to it. JMS applications can potentially switch JMS providers transparently. This freedom to change is limited only by the provider&#146;s ability to implement the specification, not the programmer&#146;s code. Of course, the messaging abstraction comes at a price. Messages are bigger than their contents, often containing a header that provides system-specific delivery information. Messages often go through the server, making them slower than direct connections. However, in many situations, these costs are far outweighed by the benefits of portable, persistent messaging.
</P>
<P>Chapter 20 introduces the syntax for JMS and discusses the provider used in the examples. Chapter 21, &#147;A JMS-Based Alarm System,&#148; is a larger JMS example; Chapter 26, &#147;MiniJMS: A Java Messaging Service Provider,&#148; includes a sample JMS provider that implements JMS using JDBC, JNDI, and</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="19-01.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="../ch20/20-01.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>


<!-- 