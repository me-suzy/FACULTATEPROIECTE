
<SCRIPT>
<!--
function displayWindow(url, width, height) {
        var Win = window.open(url,"displayWindow",'width=' + width +
	',height=' + height + ',resizable=1,scrollbars=yes');
	}
	//-->
	</SCRIPT>



<FONT FACE="Arial,Helvetica" SIZE="-1">
To access the contents, click the chapter and section titles.
</FONT>
<P>
<B>Developing Java Enterprise Applications</B>
<FONT SIZE="-1">
<BR>
<I>(Publisher: John Wiley & Sons, Inc.)</I>
<BR>
Author(s): Stephen Asbury ; Scott R. Weiner
<BR>
ISBN: 0471327565
<BR>
Publication Date: 02/01/99
</FONT>
<P>
<Script language="JavaScript">
function isIE4() 
{
    return( navigator.appName.indexOf("Microsoft") != -1 && (navigator.appVersion.charAt(0)=='4') );
 }
function bookMarkit()
{
        var url="http://www.itknowledge.com/PSUser/EWBookMarks.html?url="+window.location+"&isbn=0";
	parent.location.href=url;
        //var win = window.open(url,"myitk");
        //if(!isIE4())
        //       win.focus();

}
</Script>
<a href="javascript:bookMarkit();"><img src="/images/bookmarkit.gif" border=0 alt="Bookmark It" width=97 height=23></a>

<P>
<form name="Search" method="GET" action="http://search.earthweb.com/search97/search_redir.cgi">

<INPUT TYPE="hidden" NAME="Action" VALUE="Search">
<INPUT TYPE="hidden" NAME="SearchPage" VALUE="http://search.earthweb.com/search97/samples/forms/srchdemo.htm">
<INPUT TYPE="hidden" NAME="Collection" VALUE="ITK">
<INPUT TYPE="hidden" NAME="ResultTemplate" VALUE="itk-simple-intrabook.hts">
<INPUT TYPE="hidden" NAME="ViewTemplate" VALUE="view.hts">

<font face="arial, helvetica" size=2><b>Search this book:</b></font><br>
<INPUT NAME="queryText" size=50 VALUE="">&nbsp;<input type="submit" name="submitbutton" value="Go!">
<INPUT type=hidden NAME="section_on" VALUE="on">
<INPUT type=hidden NAME="section" VALUE="http://www.itknowledge.com/reference/standard/0471327565/">

</form>


<!-- Empty Reference Subhead -->

<!--ISBN=0471327565//-->
<!--TITLE=Developing Java Enterprise Applications//-->
<!--AUTHOR=Stephen Asbury//-->
<!--AUTHOR=Scott R. Weiner//-->
<!--PUBLISHER=Wiley Computer Publishing//-->
<!--CHAPTER=01//-->
<!--PAGES=006-008//-->
<!--UNASSIGNED1//-->
<!--UNASSIGNED2//-->

<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="01-02.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="../ch02/02-01.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>
<P><BR></P>
<P>Once you have a list of requirements, analyze them and design a set of components and objects that fulfill the requirements. At this point, start thinking about application boundaries, but don&#146;t lock yourself into saying &#147;This is an EJB&#148; or &#147;This is a JMS message.&#148; The main goal is to determine a clear set of client applications and the components that support them. For this book, the design of client applications with a user interface is left to the reader. Our focus is on the libraries that the client might use to communicate with the supporting components. The one exception is the use of Web pages as an interface to an application on the server. The book discusses these; you should use good Web page and Web site design techniques to augment the discussion. Keep in mind that some &#147;client&#148; applications may not have a user interface at all. They may be report generators or the like.
</P>
<P>Take the components that your programs need, and determine what communication mechanism they should use to interact. Possible choices are HTTP, RMI, CORBA, sockets, and JMS. HTTP is normally used for applications that use a Web page front end, but it can also be useful in situations in which the components are separated by a firewall. With the availability of RMI and CORBA, sockets should be used only when required to support existing protocols or applications. RMI and CORBA both use the concept of distributed objects, discussed in Chapter 12, &#147;Overview of Distributed Objects,&#148; to enable interapplication communication. For applications being written in pure Java, RMI provides the most native distributed object choice. Applications that need to connect to programs written in other languages should probably choose CORBA. As mentioned in the preface, this book doesn&#146;t cover CORBA, but the discussions on RMI are relevant. Finally, JMS allows programs to communicate via encapsulated messages. Messages can be sent between Java programs and even to non<SMALL>&#150;</SMALL>Java programs, depending on the provider. More discussion on reasons you might choose JMS is provided in Chapter 19, &#147;What Are Messaging and the Java Messaging Service?&#148;</P>
<P>Given the components and the protocols between them, the next step in the development process is to determine what type of component to implement. JavaServer Pages and servlets can be used to drive a Web page user interface. Servlets can also provide generic services over HTTP or some other protocol. Enterprise JavaBeans are used to define components that live on a server of some type, such as an application server. Using EJBs, you can leverage services provided by the server, such as transaction management and resource optimization. RMI and JMS can be used with EJBs or servlets as well as in applets or applications. For example, you can create an application that provides services by receiving JMS messages and sending JMS messages for the reply.</P>
<P>The final step in this process is to write the client applications and components and, of course, test them. The goal for this book is to not only help you write the applications and components but to provide some ideas and tips for making the decisions we&#146;ve discussed. In particular, the last three chapters in this book start with a review of the technologies and describe situations in which they should be used. Then two large examples are described in detailed, real<SMALL>&#150;</SMALL>world applications.</P>
<H4 ALIGN="LEFT"><A NAME="Heading10"></A><FONT COLOR="#000077">Why Use Java for Enterprise Development?</FONT></H4>
<P>Of course, you may still be asking the question, &#147;Why should I use Java for my enterprise development?&#148; It is certainly a valid question, and we would be hard pressed to argue that Java is perfect for every single programming situation. However, there are a number of great reasons to use Java for enterprise development and development in general. Let&#146;s look at the specific advantages of the Java enterprise technologies.
</P>
<P>First, despite some hiccups, Java is extremely portable. This doesn&#146;t mean solely that the programs can move between computers; it means that components such as Enterprise JavaBeans can be moved between different application servers. Using EJB, you can develop an application on one server and deploy it on another one. This can save cost, because developers don&#146;t all need a deployment environment available to them. Of course, you should always test on the deployment environment before actually deploying your enterprise applications. Sun has made &#147;Write Once, Run Everywhere&#148; a mantra and is constantly improving the availability of Java and the enterprise Java technologies. With companies such as IBM, BEA, Oracle, and Sybase on board as well as a host of innovative startups such as Cloudscape, it isn&#146;t hard to see how Java will continue to grow and improve.</P>
<P>Second, the standards defined by the enterprise Java technologies reduce education cost. Once you learn the specifications described in this book, you can apply them on multiple servers. Compare this to the old way of doing things, when programmers specialized in a particular database or transaction monitor.</P>
<P>Technologies such as Enterprise JavaBeans and servlets split an application into components and centralize code. With RMI, JNDI, and JMS, it is easy to manage the relationship between components. In other words, you can leverage technologies such as application servers to help break your code into manageable components, both during development and once they are running.</P>
<P>These technologies leverage the advantages of Java. For example, servlets allow you to plug custom code into a Web server, as a plug<SMALL>&#150;</SMALL>in or extension library would. However, servlets have garbage<SMALL>&#150;</SMALL>collection and exception<SMALL>&#150;</SMALL>handling abilities, so a problem in a servlet should not affect the server as a whole. The same is true for Enterprise JavaBeans that may be deployed on a database or application server. In both cases, Java is creating a safety zone around each enterprise application to protect it from naughty neighbors.</P>
<P>And the list goes on. We could spend several pages talking about why you should use these technologies. This list is a great start, though, and once you see what the technologies are and how they work, you will be able to fill in the list for yourself. So let&#146;s get started.</P>
<H3><A NAME="Heading11"></A><FONT COLOR="#000077">Summary</FONT></H3>
<P>As you work through the concepts and examples in this book, keep in mind the goals you have for your Java applications. Consider where each technology can be used, and think about which one is the right technology to use. Hopefully, as you reach the two final large examples at the end of the book, you will begin to think of new ways to combine the enterprise Java technologies. Ultimately, your success creating enterprise applications is limited only by your ability to choose the right technology for the job and apply it appropriately.
</P>
<P>The next two chapters introduce JDBC. This introduction is provided for programmers who have no JDBC experience and is not intended as a complete discussion of the Java database access libraries. If you are already familiar with JDBC, you may want to skip ahead to Chapter 4, &#147;What Is JNDI?&#148;</P><P><BR></P>
<CENTER>
<TABLE BORDER>
<TR>
<TD><A HREF="01-02.html">Previous</A></TD>
<TD><A HREF="../ewtoc.html">Table of Contents</A></TD>
<TD><A HREF="../ch02/02-01.html">Next</A></TD>
</TR>
</TABLE>
</CENTER>


<!-- 